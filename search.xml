<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[AMD New Horizon]]></title>
      <url>%2F2016%2F12%2F17%2FAMD-New-Horizon%2F</url>
      <content type="text"><![CDATA[AMD New Horizon:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第三版)]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%B8%89%E7%89%88%2F</url>
      <content type="text"><![CDATA[综述&emsp;&emsp;广泛意义上讲，代理是一种类，它的作用是作为其他东西的接口。代理可以成为任何东西的接口：网络连接、内存中的大型对象、文件或者是其他不可复制或复制代价很大的资源。简短来说，代理是被客户端调用，用来访问隐藏的实体服务对象的封装类或代理对象。&emsp;&emsp;代理可以简单地直接调用实体对象，也可以添加额外的逻辑。代理可以提供额外的功能，例如对资源敏感的实体对象进行缓存，或者在调用实体对象之前进行前提检查。&emsp;&emsp;对于客户端而言，使用代理对象和使用实体对象是相似的，因为二者都实现了同一个接口。 可能的应用场景远程代理&emsp;&emsp;在分布式对象通信中，本地对象是远程对象的代理对象。本地对象的方法调用的结果是远程对象的方法被调用。典型例子是ATM，ATM持有远程服务器的实体对象的代理对象。 虚拟代理&emsp;&emsp;在一些情况下，用一个大体框架来代替复杂庞大的对象的优势是很明显的。比如当一幅图片很大时用一个虚拟代理替换它，之后按需加载。 保护代理&emsp;&emsp;保护代理被用来基于访问权限，控制资源的访问。 #]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用阿里云服务器搭建PPTP协议的VPN]]></title>
      <url>%2F2016%2F12%2F13%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAPPTP%E5%8D%8F%E8%AE%AE%E7%9A%84VPN%2F</url>
      <content type="text"><![CDATA[作为运维，我手上现在有一个位于美国硅谷的阿里云ECS服务器。秉承物尽其用的原则，正好搭建一个VPN服务器。 环境介绍 CPU：1核心Haswell架构的处理器 内存：1GB+自己配置的4GB的Swapfile(相当于虚拟内存) 操作系统：Ubuntu14.04LTS 64位 准备工作Linux平台准备12345//安装openssh-clientsudo apt install openssh-client//连接服务器//例如ssh root@127.0.0.1 //ssh 用户名@服务器的公网IP Windows平台准备 安装PuTTY或者XShell，想要更傻瓜操作一点可以安装WinSCP供后续使用 使用PuTTY或者XShell连接服务器 安卓平台准备我就是用我的小米4C上软工课无聊配置得VPN哈哈哈哈，所以我也写一下好了 安装connectBot(详见GitHub) 使用connectBot连接服务器 安装有关软件12//服务器上sudo apt install ppp iptables pptpd 炒鸡简单是吧 更改相关配置更改使用的工具命令行123456vi /file //或者vim//用上下键移动光标到需要修改的那一行，按“i”键进入插入编辑状态，修改完成之后，按“esc”键退出编辑，直接在键盘上输入“:wq&quot;即可保存退出。//好在不一定要用vi/vim，用nano也OKnano /file//上下左右都能移动光标，除了不能用鼠标以外没什么难度。修改完成按Ctrl+X，问是否保存按Y，之后保存名称不用改直接回车。找不到就按Ctrl+W查找就是。 nano的具体操作可以看我使用过的Linux命令之nano - 比vi简单易用的文本编辑器 图形化使用WinSCP以root用户登录，使用WinSCP提供的文本编辑功能双击修改即可。修改完成之后Ctrl+S保存，问你是否覆盖，选是即可。 修改配置文件(以使用nano为例)编辑pptpd.conf1234nano /etc/pptpd.conf//找到#localip 192.168.0.1// #remoteip 192.168.0.234-238,192.168.0.245//删去#号即可 编辑options12345nano /etc/ppp/options//搜索ms-dns，去掉搜索到的两行ms-dns前面的#，并修改为下面的字段//ms-dns 8.8.8.8//ms-dns 8.8.4.4 编辑chap-secrets12345nano /etc/ppp/chap-secrets//添加一行，按照下面格式输入：//用户名 pptpd 密码 *//比如 zizhuo pptpd zizhuo *//*的含义是不限制连接者的IP地址，想要限制的话改成那个IP即可 编辑sysctl.conf(内核文件)1234nano /etc/sysctl.conf//将net.ipv4.ip_forward=0//改成net.ipv4.ip_forward=1 添加iptables转发规则1iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -j MASQUERADE 说明： --table -t table table to manipulate (default: `filter’) --append -A chain Append to chain --source -s address[/mask][…] source specification --out-interface -o output name[+] &emsp;network interface name &emsp;eth1是阿里云服务器的连接外网的网卡，可以用ifconfig看一下哪一块网卡是外网IP就可以 –jump -j target &emsp;&emsp;target for rule (may load target extension) 启动pptpd123sudo service pptpd restart//或者/etc/init.d/pptpd restart 设置开机自启貌似现在默认就可以，不过我还是说一下吧1234//Ubutnu没有chkconfig，可以用rcconfsudo apt install rcconfrcconf on//之后会看到菜单，按空格选择开启/关闭，Tab键跳出选择OK/Cancel 结束去看看所谓的“真实世界”吧2333，下篇文章再见。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[归一化谷歌距离的计算方法]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%BD%92%E4%B8%80%E5%8C%96%E8%B0%B7%E6%AD%8C%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[归一化谷歌距离的计算方法71115115 王子卓 摘要&emsp;&emsp;归一化Google距离（Normalized Google Distance）是一种语义相似性的度量方法，由给定一组关键词集合的Google搜索引擎所返回的命中数量得出。&emsp;&emsp;在自然语言中，具有相同或相似意思的两个关键字在以归一化谷歌距离为单位的情况下趋向于“接近”，意思不同的两个关键字则趋向于“疏远”。本文重点介绍如何使用Java语言和百度搜索引擎实现归一化谷歌距离的计算。&emsp;&emsp;关键字：Normalized Google Distance 、 Java 、百度搜索 1.归一化谷歌距离1.1定义&emsp;&emsp;归一化谷歌距离是以搜索引擎提供的关键字搜索结果数量为计算依据，对语义相似程度的度量方法。&emsp;&emsp;具体而言，两个搜索关键词之间x和y之间的归一化谷歌距离可以用下式表示：&emsp;&emsp;其中：f(x)表示在搜索引擎中搜索x时返回的匹配记录数;f(y)表示在搜索引擎中搜索y时返回的匹配记录数;f(x,y)表示在搜索引擎中搜索词组(x,y)时返回的匹配记录数;M表示搜索引擎总索引量。上式中log均表示自然对数。 1.2分析1.2.1取值范围&emsp;&emsp;NGD(x,y)的取值范围为[0,∞]。如果两个搜索词x和y从未一起出现在同一网页上，而是单独出现时，则他们之间的归一化谷歌距离是无穷。如果两个词总是同时出现，则他们的归一化谷歌距离是0。&emsp;&emsp;一般情况下，NGD(x,y)越接近于0，x、y越相似。如果NGD(x,y)大于等于1，则x、y之间区别很大。&emsp;&emsp;特殊情况下，由于搜索引擎结果不准确，NGD(x,y)可能会小于0。 1.2.2满足规律&emsp;&emsp;在搜索引擎足够准确的情况下 NGD(x,x)等于0，满足同一律。 NGD(x,y)等于NGD(y,x)，满足交换律。 1.2.3尺度不变性&emsp;&emsp;归一化谷歌距离具有尺度不变性。设想如果搜索引擎总的索引量M增长了n倍，那么f(x)、f(y)、f(x,y)也应该增长n倍。这是因为归一化谷歌距离提供给我们搜索关键字之间客观语义联系，当M以一个不确定的比例增长时，NGD(x,y)应该保持稳定。 2.利用百度搜索引擎和Java语言实现谷歌距离的计算2.1设计思路 NormalizedGoogleDistance类 公有静态函数NGD(String a,String b),返回值为Double类型。作用是获取网页的源代码，使用正则表达式匹配三种情况下搜索索引个数，并且将值传递给Calculate函数做计算。 公有静态函数Calculate(Double numA,Double numB,Double numC)，返回值为Double类型。计算并返回归一化谷歌距离的计算结果。 公有静态函数main(String[] args)，返回值为空。接受从命令行传来的两个关键字参数，调用NGD函数计算结果并输出。 2.2具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.regex.*;public class NormalizedGoogleDistance &#123; /** * @param a * @param b * @return The result of NGD */ public static Double NGD(String a,String b)&#123; //删去空格，以防搜索出错 a=a.replaceAll(" ", ""); b=b.replaceAll(" ", ""); //正则表达式匹配个数 String regex = "百度为您找到相关结果约(.*)个"; Pattern pattern = Pattern.compile(regex); //用于存三次搜索各自的索引量 Double numA,numB,numC; numA=1.0;numB=1.0;numC=1.0; try &#123; //三次搜索，三次连接，三个缓存阅读器 URL baiduURL1 = new URL("http://www.baidu.com/s?wd="+a); URL baiduURL2 = new URL("http://www.baidu.com/s?wd="+b); URL baiduURL3 = new URL("http://www.baidu.com/s?wd="+a+b); URLConnection connection1 = baiduURL1.openConnection(); URLConnection connection2 = baiduURL2.openConnection(); URLConnection connection3 = baiduURL3.openConnection(); BufferedReader in1 = new BufferedReader(new InputStreamReader(connection1.getInputStream())); BufferedReader in2 = new BufferedReader(new InputStreamReader(connection2.getInputStream())); BufferedReader in3 = new BufferedReader(new InputStreamReader(connection3.getInputStream())); //逐行筛选匹配正则表达式，并将结果中的逗号删除，之后转化成数字。 String html1 = in1.readLine(); while(html1!=null)&#123; Matcher matcher = pattern.matcher(html1); while(matcher.find())&#123; System.out.println(a+": "+matcher.group(1)); String temp = matcher.group(1); numA=Double.parseDouble(temp.replaceAll(",", "")); &#125; html1 = in1.readLine(); &#125; //逐行筛选匹配正则表达式，并将结果中的逗号删除，之后转化成数字。 String html2 = in2.readLine(); while(html2!=null)&#123; Matcher matcher = pattern.matcher(html2); while(matcher.find())&#123; System.out.println(b+": "+matcher.group(1)); String temp = matcher.group(1); numB=Double.parseDouble(temp.replaceAll(",", "")); &#125; html2 = in2.readLine(); &#125; //逐行筛选匹配正则表达式，并将结果中的逗号删除，之后转化成数字。 String html3 = in3.readLine(); while(html3!=null)&#123; Matcher matcher = pattern.matcher(html3); while(matcher.find())&#123; System.out.println(a+"+"+b+": "+matcher.group(1)); String temp = matcher.group(1); numC=Double.parseDouble(temp.replaceAll(",", "")); &#125; html3 = in3.readLine(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //返回Calculate函数的计算结果 return Calculate(numA, numB, numC); &#125; /** * @param numA * @param numB * @param numC * @return NGD公式计算结果 */ public static Double Calculate(Double numA,Double numB,Double numC)&#123; Double lnx = Math.log(numA); Double lny = Math.log(numB); Double lnSum = Math.log(25270000000.0);//由于百度有索引总量限制，在此使用谷歌搜索总索引量 Double lnxy = Math.log(numC); //NGD公式 if (lnx&gt;lny) &#123; return (lnx-lnxy)/(lnSum-lny); &#125;else &#123; return (lny-lnxy)/(lnSum-lnx); &#125; &#125; /** * @param args * 从外部传进两个参数作为关键字，并将结果输出 */ public static void main(String[] args) &#123; Double result = NGD(args[0], args[1]); System.out.println("NGD: "+result); &#125;&#125; 参考文献【1】RudiL.Cilibrasi and PaulM.B.Vitanyi. The Google Similarity Distance 【J】IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, VOL.19, NO3, MARCH2007, P370–383【2】张玉芳,艾东梅,黄 涛,熊忠阳.结合编辑距离和Google距离的语义标注方法 【A】计算机应用研究，2010年2月，第二期，第二十七卷【3】匿名. Normalized Google distance，维基百科，https://en.wikipedia.org/wiki/Normalized_Google_distance【4】pinyangtenglong的专栏. 归一化Google距离（Normalized Google Distance），CSDN博客，http://blog.csdn.net/pinyangtenglong/article/details/26963015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第二版)]]></title>
      <url>%2F2016%2F12%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E7%89%88%2F</url>
      <content type="text"><![CDATA[之前的例子可能不太恰当，于是我就又想了一个例子。 定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 大体思路 德云社有很多分社，遍布大江南北。人们每每提到德云社，总是对一种剧场的总称。因此德云社是一种接口。它有enter进入方法。 南京德云社是全国的德云社之一，每当有人enter进入就会提示。 售票员Conductor也是德云社一员，他可以是任何德云社的售票员。售票员会提前咨询场馆有多少座位，max由剧场座位数seats决定。超过max人就禁止观众进入。 观众Audience都有名字，可以进入任意的德云社。观众必须经过售票员，售票员是哪个德云社的代理，观众就进入哪一个。 UML类图 实际代码德云社接口1234public interface DeYunShe &#123; void enter(Audience audience); int getSeats();&#125; 南京德云社123456789101112public class NanJingDeYunShe implements DeYunShe &#123; public static final int seats=3; @Override public void enter(Audience audience) &#123; System.out.println(audience.getName()+" entered!"); &#125; @Override public int getSeats() &#123; return seats; &#125;&#125; 售票员1234567891011121314151617181920212223242526public class Conductor implements DeYunShe &#123; private int max=0; private int audiences=0; private DeYunShe dys; public Conductor(DeYunShe dys) &#123; this.dys = dys; &#125; @Override public int getSeats() &#123; max = dys.getSeats(); return 0; &#125; @Override public void enter(Audience audience) &#123; if (audiences&lt;max) &#123; dys.enter(audience); audiences++; &#125;else &#123; System.out.println(audience.getName()+" is not allowed to enter!"); &#125; &#125;&#125; 观众123456789public class Audience &#123; private String name; public Audience(String n) &#123; name = n; &#125; public String getName()&#123; return name; &#125;&#125; 测试123456789public class Test &#123; public static void main(String[] args) &#123; Conductor proxy = new Conductor(new NanJingDeYunShe()); for(int i=1;i&lt;=5;i++)&#123; proxy.enter(new Audience("Audience"+i)); &#125; &#125;&#125; 运行结果 实验请将本例补充完整，并且增加北京德云社，让另一个售票员做它的代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[太平歌词白蛇传]]></title>
      <url>%2F2016%2F12%2F04%2F%E5%A4%AA%E5%B9%B3%E6%AD%8C%E8%AF%8D%E7%99%BD%E8%9B%87%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[太平歌词白蛇传唱词个人整理 我认为应该这样停顿，就简单的画了一下 我爱这门艺术，不希望它完了 杭州/美景/盖世无双西湖岸/奇花异草/四（了）季（个）清香春游/苏堤/桃红柳绿那夏赏/荷花/映满了池塘这秋观/明月/如同碧水冬看/瑞雪/铺满了山岗我表的是/峨眉山白蛇下界在这上天/怒恼了张玉皇怒冲冲/差法海/临了凡界在这金山/寺内把这方丈当这一天/许汉文/烧香还愿老法海/拦去路/有语开腔我算定/你的妻/多了年的怪蟒缠绕你/结连理/盗取真阳有许仙/闻此言/魂飞魄散留在了/文殊院/未转钱塘青白蛇/一怒就找到了寺院那手指/山门骂和尚放出来/儿夫还则罢了若不然/青锋剑下秃头命亡众僧人/急忙忙/把这山门关上那抱头/鼠窜/往内藏小青儿/拘来了/这个虾兵蟹将众水族/显神通/水淹佛堂老法海/坐在了莲台/掐诀念咒那水也涨/庙也长/漫不了山墙钱塘县的/众黎民/遭了涂炭数十万/生灵在水内亡半悬空/又来了/天兵天将那金吒木吒哪吒太子/托塔的天王四值/功曹/二十八宿那梅山/六将/灌口的杨二郎李天王/一怒就祭起了宝塔脸森森/要把这白蛇来伤魁星爷/发恻隐/放她逃走只因她/腹内怀有状元郎老法海唤过了许仙/开言道我赐你/佛钵/去把妖降许汉文/接过了佛钵/心肠硬扭回/头来/够奔了钱塘在这一(呀)路上/点点/飘散/桃杏雨潇潇/不断/柳风扬顾不得/连理枝儿/狂风吹散顾不得/比翼鸟儿/棍下伤亡玉碎/珠沉人何在(哎这)镜花/水月两分张穿大街/过小巷/来的多么快启珠帘/走进来这负心郎白娘子/见佛钵/得得得得颤战兢兢/玉体/粉了面的娇惶尊丈夫/高抬手/把奴容让止不住/秋波儿/泪(了)洒胸膛曾记得/游湖借伞百般恩爱曾记得/那红罗帐下/会鸳鸯那五月/初五/端阳日大不该/夫妻对坐饮雄黄三杯酒/下咽喉/醉倒在绡金帐(嘞嘿)现原形/吓得儿夫/命见阎王奴为你/长寿山/盗来了还阳草还与那/守山的神将/是大战了一场多亏了/寿星爷/发了恻隐赠了那/保命丹/我这转回了家乡我进门来呀/用金丹那/撬牙关/把这金丹灌下搭救/儿夫你转还阳我只说/到金山/你是烧香还愿有谁知/飞灾横祸落在身旁到如今你手托佛钵/回家转口口/声声要把妖降看起来/红颜薄命/真命苦空叫我/眼泪流干/寸断了肝肠奴好比/月当空被这乌云遮上奴好比/瓦上霜我是难见日光奴好比/弓断弦我是回天无术奴好比/泥牛入海隐入汪洋我这看起来/人生苦短无药救不由得/两泪流干散落胸膛忙把娇儿怀中抱为娘我/有句话/细听端详再吃口/为娘断肠的乳从今/往后离了亲娘埋怨/休把娘埋怨埋怨/你父丧尽了天良回头来/忙把这青儿叫你与我/扶养这小儿郎忙把娇儿递过去这刷拉拉/佛钵放了豪光白娘子/压在了这雷峰塔终朝每日/受凄凉好可叹/十八年/灾数才满许梦娇/中状元/雷峰塔下见了亲娘我一言/唱不尽这白蛇传/我是愿诸位/合家欢乐是福寿绵长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式]]></title>
      <url>%2F2016%2F11%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 UML 角色及职责 Subject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。 Proxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后工作。 应用场景举例(老司机发车咯)代理模式好有一比。比从何来？好比西门庆找潘金莲，让王婆做代理。(营养跟不上的请自觉下车233)首先，我们先定义这种女人。一种类型嘛，肯定要是接口12345678public interface KindWoman &#123; //这种女人能做什么事情呢？ public void makeEyesWithMan();//抛媚眼 public void happyWithMan();//你懂得 &#125; 之后，我们要有潘金莲 1234567891011121314public class PanJinLian implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("潘金莲和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("潘金莲抛媚眼..."); &#125;&#125; 然后王婆登场 123456789101112131415161718192021222324252627public class WangPo implements KindWoman &#123; private KindWoman kindWoman; public WangPo()&#123; //默认的话是潘金莲的代理 this.kindWoman = new PanJinLian(); &#125; //她可以是KindWoman的任何一个女人的代理，只要你是这一类型 public WangPo(KindWoman kindWoman)&#123; this.kindWoman = kindWoman; &#125; @Override public void happyWithMan() &#123; //自己老了，但可以叫年轻的代替。 this.kindWoman.happyWithMan(); &#125; @Override public void makeEyesWithMan() &#123; //王婆年纪大了，谁看她抛媚眼啊 this.kindWoman.makeEyesWithMan(); &#125;&#125; 女主角都上场了，接下来该男主角西门大官人了 123456789101112131415161718192021/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); &#125;&#125; 之后再来个玉堂春吧233，虽然不是一个时代(详见《三堂会审玉堂春》)。 1234567891011121314public class YuTangChun implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("玉堂春和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("玉堂春抛媚眼..."); &#125;&#125; 这之后，西门庆可以勾搭玉堂春123456789101112131415161718192021222324252627/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有，表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); //西门庆勾搭玉堂春 YuTangChun yuTangChun = new YuTangChun(); wangPo = new WangPo(yuTangChun); wangPo.makeEyesWithMan(); wangPo.happyWithMan(); &#125;&#125; 故事背后深层含义(车到站了哦)代理模式主要使用了java的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚得很，同样一个接口呗。今天老司机就开到这里吧，红红火火恍恍惚惚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线索二叉树的遍历方法]]></title>
      <url>%2F2016%2F11%2F22%2F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[求各种次序线索树非叶子结点的前驱和后继的方法： 前序线索树非叶子结点p的前驱：p的双亲结点； 前序线索树非叶子结点p的后继：若p有左孩子，则后继为其左孩子，否则后继是其右孩子。 后序线索树非叶子结点p的前驱：若p有右孩子，则后继为其右孩子；否则后继是其左孩子。 后序线索树非叶子结点p的后继：若p为根结点，则其后继为空；若p为其双亲结点的右孩子，或p为左孩子且其双亲结点无右孩子，则p的后继为其双亲结点； 若p为左孩子，且其双亲结点有右孩子，则其后继为双亲结点右子树的第一个结点（最左边结点）。 中序线索树非叶子结点p的前驱：左子树的最后一个结点（最右边的结点）。 中序线索树非叶子结点p的后继：右子树的第一个结点（最左边结点）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Umbrello UML 文档个人翻译]]></title>
      <url>%2F2016%2F11%2F01%2FUmbrello-UML-%E6%96%87%E6%A1%A3%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91%2F</url>
      <content type="text"><![CDATA[只是关于UML基础知识部分的翻译 UML基础关于UML这一章节会给你一个UML基础知识的概览。一定要记住，这不是一个综合的UML教程，而只是一个可以当做UML教程的对UML的简要介绍。统一建模语言(UML)是一个图表语言，或者说是用来指定、可视化和文档化面向对象软件的模型的标记法。UML不是一种开发方法，这也就意味着它不会一五一十地告诉你每一步要做什么和如何设计你的系统，但是它可以帮助你可视化你的设计和与他人沟通。UML为面向对象程序设计而生，对其他编程模式作用有限。UML由许多模板元素组成，这些模板元素代表着软件系统的不同部分。UML的元素被用来创建示意图，这些示意图代表着一个软件系统的一部分或者一个方面。Umbrello支持以下的这些表： 用例图：展示演员（系统的用户）、用例（用户使用系统的情形）以及他们之间的关系。 类图：展示类和他们之间的关系。 顺序图：展示对象以及一系列的对象对其他对象的方法调用。 协作图：展示对象和他们之间的关系，重点强调参与信息传递的对象。 状态图：展示状态、状态变化以及对象或一部分系统中的事件。 活动图：展示活动以及伴随着部分系统的事件而产生的活动改变。 组件图：展示高级编程组件。比如KParts和Java Beans 配置图：展示组件的实例和它们之间的关系。 实体关系图：展示数据、关系以及数据之间的约束。 UML元素用例图用例图描述一组用例以及参与这个过程的演员之间的关系和依赖。 一定要注意，用例图不适合描述设计，也不能描述系统的内部。用例图是为简化与未来的系统用户、顾客的交流而生的，对决定系统的需求有很大帮助。用例图可以说明系统是做什么的，但是不会也不能确定如何去做。 用例用例站在演员的角度描述一组系统中的产生确定结果的活动。用例是系统中成员和系统自身的特殊互动的描述。它们代表系统的外部接口，并且指定系统要做什么。 使用用例的时候，一定要注意以下几点： 每一个用例至少和一位演员关联 每一个用例都有一个发起人 每一个用例都会产生相关结果 用例之间也可以有联系，其中有三种联系最为典型： &lt;&lt;include&gt;&gt;指一个用例发生在另一个用例之中 &lt;&lt;extends&gt;&gt;指在某些情况或者某些点（扩展点），一个用例被另一个扩展 Generalization指一个用例继承一个“高级”用例的特性，可以像类继承一样覆盖或者添加特性 演员演员是系统之外的实体，他们以参与用例的方式与系统交互。他们可以是人、其他电脑系统或者外部事件。 演员不代表实体人或者系统，而是角色。也就是说一个人在做不同操作时可以是不同的演员。 用例描述用例描述是用例的文本描述，通常以连接用例的笔记或文档的形式，解释发生在用例中的过程或活动。 类图类图展示组成系统的不同类以及它们之间关联的方式。类图是静态图表，因为虽然它展示了类之间的关系，但是没有展示它们之间的调用方法。 类一个类定义了一组对象的属性和方法。所有这个类的对象共享同样的行为，具有同种属性（各有各的值）。类和类型不一样，类型意思更广泛。 在UML中，矩形代表类，分为三个部分，分别写有类名、属性（成员变量）、操作（函数、方法）。 属性在UML中，属性最少要展示它们的名字，也可以展示它们的类型、初值等其他属性。属性也可以展示它们的可见度： +代表公有属性（public） #代表保护属性（protected） -代表私有属性（private） 操作操作（方法）也是最少要展示它们的名字，还可以展示它们的参数列表和返回值。像属性一样，操作也可以展示他们的可见度： +代表公有操作（public） #代表保护操作（protected） -代表私有操作（private） 模板类里面可以有模板，它是一个未指定的类或类型。模板在类初始化的时候特化（比如一个对象生成时）。模板存在于现代C++以及Java1.5以后的版本（称为泛型） 类之间的联系类之间可以有多种联系： 泛化继承是面向对象编程的基本概念。子类可以获得父类的所有属性和操作，也可以覆盖或修改其中的一部分，还可以添加自己的属性和操作。 在UML中，两个类之间的泛化联系分层展示了基类和派生类之间的继承关系。在UML中，泛化由连接两个类的直线和指向基类的箭头表示。 关联关联是类之间的一种关系，给出一般语义和结构用来说明对象之间的多种”联系”方式。 关联是对象之间的交流机制，它描述了不同类之间的关系（实体对象之间的联系称为object connection，也叫链接（link））。 关联可以在特化联系的目的中起作用，可以是单向的也可以是双向的(indicates if the two objects participating in the relationship can send messages to the other, of if only one of them knows about the other)。 关联的两端各有一个数值，它们规定了关联一端的一个对象能和另一端的多少对象联系。 在UML中，关联被表示成连接具有关联关系的两个类的直线，它也可以展示参与者的角色以及数量。数量被表示成非负数的一个范围[min..max]，如果max一端是*，则代表无穷。 聚合聚合是两个不等权参与类之间的特殊联系。两个参与类之间构成”整体-部分”关系。聚合关系描述”整体类”是如何由”部分类”构成的。对于聚合关系来说，”整体类”数量永远只能为1。 在UML中，聚合由”整体类”一侧有空心菱形的直线来表示。 组合组合是一种非常强的聚合。组合中的”部分类”只能依存于”整体类”而存在。整体消亡则部分消亡。比如书和书中的章节。 在UML中，组合由”整体类”一侧有实心菱形的直线来表示。 其他类图组件类图中除了类还有其他的组件。 接口借口是抽象的类，不能直接产生实例。它们可以包含操作，但是不能包含属性。类可以继承与实现接口，之后产生实例。 数据类型数据类型是编程语言内置的基元，比如整形数和布尔型数。它们不能与类关联，但是类可以与它们关联。 枚举枚举是值的简单列表，比如一周七天。枚举的选项称为枚举常量。像数据类型一样，它们不能与类关联，但是类可以与它们关联。 包包代表编程语言中的命名空间。在图表中它们被用来表示系统的一部分。它可以包含多个甚至上百个类。 顺序图顺序图展示了指定时间界限内多个对象之间的信息交换。对象是类的实例。顺序图特别强调了对象发送信息的顺序和时间。 在顺序图中，垂直的虚线代表对象，并且对象的名字写在最上端。时间轴也是垂直的，越向下时间越晚。因此信息在对象间以带有操作和参数的箭头的形式传递。 消息可以是同步的，那种普通的信息调用，这时控制权被传递给被调用的对象直到方法结束。也可以是异步的，控制权一直在主调对象。同步消息在被调对象那里有一个垂直的方框，用来展示程序控制流。 协作图协作图展示参与特定事件的对象之间的互动。协作图展示的信息或多或少的与顺序图有相似之处，但是顺序图更加侧重于强调互动何时发生，而协作图突出对象之间的关系和拓扑结构。 在协作图当中，对象之间的信息传递用箭头表示，展现了信息的名称、参数以及信息的顺序。协作图非常适合展示一个特定的程序流或者情形，而且它还是最好的说明或解释程序逻辑的一个过程的图表之一。 状态机图状态图展示一个对象生命周期中的不同状态以及使对象改变状态的刺激(stimuli)。 状态机图将对象看作状态机(state machines)或者有限的自动化，它可以处于有限多个状态中的一个状态，并且可以因为有限多种状态之中的一种而改变它的状态。比如说一个网络服务器类型的对象在它的生命周期中可以有以下状态： 就绪 监听 运行 停止 可以让它改变状态的事件有： 对象被创建 对象收到监听信息 有客户端通过网络请求连接 有客户端终止请求 请求被执行并且结束 对象收到停止信息 …… 状态状态是状态机图的砖瓦。一个状态确定的属于一个类，它代表了一个类的属性的值的集合。一个UML状态描述了一个特定的类的一个对象的内部状态。 要注意，不是每一个对象属性的变化都应该用状态表示，只有明显影响对象的工作状态的变化才用状态表示。 有两种状态是特殊的：开始和结束。之所以说它们特殊，是因为没有任何事件可以让对象返回初始状态或离开结束状态。 活动图活动图描述系统中活动的顺序,是一种只含有活动或者大部分是活动，特殊类型的状态机图。 活动图比较类似于程序流图，不同在于所有的活动都清楚地与对象连接。 活动图永远和类、操作或用例相关联。 活动图支持顺序和并行的活动。 活动一个活动是一个流程中的一步。一个活动是系统的一个状态，它带有内部的活动以及至少一个的外部转换(outgoing transition)。如果存在不同的情况，活动也可以有多个外部转换。 活动也可以有层次结构。活动需要体现子图的向内向外转换。（an Activity can be composed of several ‘detail’ Activities, in which case the incoming and outgoing transitions should match the incoming and outgoing transitions of the detail diagram.）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(3) chgrp]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-3-chgrp%2F</url>
      <content type="text"><![CDATA[Linux chgrp命令Linux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...] 参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 实例实例1：改变文件的群组属性：chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log [root@localhost test]# chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 说明： 将log2012.log文件由root群组改为bin群组 实例2：根据指定文件改变文件的群组属性chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root root 61 11-13 06:03 log2013.log [root@localhost test]# chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log 说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(2) chattr]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-2-chattr%2F</url>
      <content type="text"><![CDATA[Linux命令(2) chattrLinux chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途。即append,设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件，只有root才能设定这个属性。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 语法chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...] 参数 -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 实例用chattr命令防止系统中某个关键文件被修改：chattr +i /etc/resolv.conflsattr /etc/resolv.conf会显示如下属性----i-------- /etc/resolv.conf 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：chattr +a /var/log/messages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(1) cat]]></title>
      <url>%2F2016%2F10%2F28%2FLinux%E5%91%BD%E4%BB%A4-1-cat%2F</url>
      <content type="text"><![CDATA[Linux命令(1) catcat命令用于把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案) 使用权限所有用户 语法格式cat [-AbeEnstTuv] [--help] [--version] fileName 参数说明 -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 实例说明把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -n textfile1 &gt; textfile2 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。cat -b textfile1 textfile2 &gt;&gt; textfile3 清空/etc/test.txt档案内容cat /dev/null &gt; /etc/test.txt cat 也可以用来制作镜像文件。例如要制作软碟的像文件，将软碟放好后输入cat /dev/fd0 &gt; OUTFILE 相反的，如果想把 image file 写到软碟，请输入cat IMG_FILE &gt; /dev/fd0 备注 OUTFILE 指输出的镜像文件名。 IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用在制作开机磁片。]]></content>
    </entry>

    
  
  
</search>
