<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[算法作业三]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%B8%89%2F</url>
      <content type="text"><![CDATA[第三次作业71115115 王子卓3-11234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ZuiChangDanDiaoDiZengZiXuLie &#123; public int[] ZCDDZDZXL(int[] a)&#123; int i=1,j=0,k=0,n=a.length; int[] b = new int[n]; //b数组的各个元素负责存储以a数组中序号对应的各个元素为结尾的最长单调子序列长度 b[0] = 1; for(;i&lt;n;i++)&#123; for(;j&lt;i;j++)&#123; if(a[j]&lt;=a[i]&amp;&amp;k&lt;b[j]) k=b[j]; &#125; b[i] = k+1; &#125; return maxLength(n, b); &#125; public int[] maxLength(int n,int[] b)&#123; int temp=0,i=0,flag=0; for(;i&lt;n;i++)&#123; if(b[i]&gt;temp)&#123; temp=b[i]; flag = i; &#125; &#125; int[] msg = new int[2]; msg[0] = flag; msg[1] = temp; return msg; &#125; public static void main(String[] args) &#123; ZuiChangDanDiaoDiZengZiXuLie xuLie = new ZuiChangDanDiaoDiZengZiXuLie(); int[] a = &#123;0,1,2,3,4,3,5&#125;; int[] length = xuLie.ZCDDZDZXL(a); System.out.println("子序列末尾元素角标"+length[0]+"\n最长单调递增子序列长度"+length[1]); int biggest=0; for(int i=0;i&lt;length[0]+1;i++)&#123; if(i==0)&#123; System.out.println(a[i]); biggest = a[i]; &#125;else if(a[i]&gt;=biggest)&#123; System.out.println(a[i]); biggest = a[i]; &#125; &#125; &#125;&#125; 3-2123456789101112131415161718192021222324252627public class AdvancedZCDDDZZXL &#123; public int LIS(int[] a)&#123; int[] b = new int[a.length]; b[1] = a[0]; int k = 1; for(int i=1;i&lt;a.length;i++)&#123; if(a[i]&gt;=b[k])&#123; b[++k] = a[i]; &#125;else&#123; b[binary(i, k, a, b)] = a[i]; &#125; &#125; return k; &#125; public int binary(int i,int k,int[] a,int[] b)&#123; if(a[i]&lt;b[1]) return 1; int j=k; for(int h=1;h!=j-1;)&#123; if(b[k=(h+j)/2]&lt;=a[i]) h=k; else j=k; &#125; return j; &#125;&#125; 3-4 该问题是二维0-1背包问题。 对于给定的$$c&gt;0,d&gt;0,\omega_i&gt;0,b_i&gt;0,v_i&gt;0, 1\le{i}\le{n}$$ 要求找出n元0-1向量$$(x_1,x_2,…,x_n),xi\in{0,1},1\le{i}\le{n}$$使得$$\sum{i=1}^{n}\omega_ixi\le{c}, \sum{i=1}^nb_ixi\le{d}$$而且使$$\sum{i=1}^nv_ix_i$$达到最大值。 由此可知，二维0-1背包问题是整数规划问题。$$max\sum_{i=1}^{n}v_ixi\\left{\begin{array}\\sum{i=1}^{n}\omega_ixi\le{c}\\sum{i=1}^{n}b_ix_i\le{d}\x_i\in{0,1},1\le{i}\le{n}\end{array}\right.$$ 该问题具有最优子结构性质。设该问题的子问题$$max\sum_{t=i}^{n}v_txt\\left{\begin{array}\\sum{t=i}^{n}\omega_txt\le{j}\\sum{t=i}^{n}b_tx_t\le{k}\x_i\in{0,1},i\le{t}\le{n}\end{array}\right.$$ 的最优解为$$m(i,j,k)$$，背包容量为j，容积为k，可选择的物品为$$i,i+1,…,n$$时该问题的最优值。 由二维0-1背包问题的最优子结构性质，可得：$$m(i,j,k)=\left{\begin{array}\max{m(i+1,j),m(i+1,j-\omega_i,k-b_i)+v_i}\ \ \ \ j\ge\omega_i且k\ge{b_i}\m(i+1,j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0\le{j}\le{\omega_i}或0\le{k}\le{b_i}\end{array}\right.$$ $$m(n,j,k) =\left{\begin{array}\v_n \ \ \ \ \ j\ge{\omega_n}且k\ge{b_n}\0 \ \ \ \ \ \ \ 0\le{j}&lt;{\omega_n}或0\le{k}&lt;b_n\end{array}\right.$$ 由上式可知$$m(n,c,d)$$为最优值。算法所需的计算时间为$$O(ncd)$$。 4-1 设变量$$x_i=1$$表示将$$l_i$$存放在$$T_1$$上，并且$$T_1$$的检索时间短于$$T2$$$$\sum{i=1}^{n}l_ixi\le\sum{i=1}^{n}l_i(1-xi)\\sum{i=1}^{n}l_ixi\le\frac{1}{2}\sum{i=1}^{n}l_i$$ $$T1$$的检索时间应取最大值，即$$max\sum{i=1}^{n}l_ixi\使得\sum{i=1}^{n}l_ixi\le\frac{1}{2}\sum{i=1}^{n}l_i$$ 最小生成树算法的正确性Prim算法 Prim算法的思路是，从任意一个顶点开始，把这个顶点作为最初的最小生成树的子树，通过逐步地为当前的子树添加新边来生成最终的最小生成树，添加的策略是，每次只添加从外部连接到该子树的所有边中的最短边。 对于任意一个顶点vi，连接到该顶点的所有边中的一条最短边$$(v_i,v_j)$$必然属于最小生成树。 假设最小生成树已经建成，$$(v_i,v_j)$$是连接到顶点vi的最短边，在最小生成树中取出vi，断开连接到vi的边，则生成树被拆分成 顶点$$v_i$$ 顶点$$v_j$$所在的连通分量（单独一个顶点也看作一个独立的连通分量） 其余若干个连通分量（个数大于等于0） 三个部分 现在要重建生成树，就要重新连接之前被断开的各边。 虽然不知道之前被断开的都是哪几条边，但是可以通过这样一个简单的策略来重建连接：将$$v_i$$分别以最小的成本逐个连接到这若干个互相分离的连通分量。具体来说，就是要分别遍历顶点$$v_i$$到某个连通分量中的所有顶点的连接，然后选择其中最短的边来连接$$v_i$$和该连通分量；而要将$$v_i$$连接到$$v_j$$所在的连通分量，显然通过边$$(v_i,v_j)$$连接的成本最低，所以边$$(v_i,v_j)$$必然属于最小生成树（如果连接到$$v_i$$的最短边不止一条，只要任意挑选其中的一条$$(v_i,v_j)$$即可，以上的证明对于这种情况同样适用）。这样我们就为原来只有一个顶点$$v_i$$的子树添加了一个新的顶点vj及新边$$(v_i,v_j)$$。接下来只要将这棵新子树作为一个连通子图，并且用这个连通子图替换顶点$$v_i$$重复以上的分析，迭代地为子树逐个地添加新顶点和新边即可。 Kruskal算法 Kruskal算法通过从小到大遍历边集，每次尝试为最小生成树加入当前最短的边，加入成功的条件是该边不会在当前已构建的图中造成回路，当加入的边的数目达到n-1，遍历结束。 Kruskal算法每次为当前的图添加一条不会造成回路的新边，其本质是逐步地连接当前彼此分散的各个连通分量（单个顶点也算作一个连通分量），而连接的策略是每次只用最小的成本连接任意两个连通分量。这个策略之所以能够实现，是因为每加入一条边之后只会出现两种结果： 在已有的连通分量中形成回路 连接两个彼此独立的连通分量 所以，通过从小到大遍历边集，判断是否会造成回路，然后逐条添加新边就可以实现上诉的连接策略。 如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树当最小生成树被拆分成彼此独立的若干个连通分量的时候，因为该边必然是这两个连通分量的可以连接到外部的最短边，所以所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树。 由此也就证明了，Kruskal算法通过每次以最小的成本来连接两个连通分量的策略确实可以正确地生成最小生成树。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法作业二]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[第二次作业71115115 王子卓2-2(1)left和right游标的调整不正确，应改为：12if(x&gt;a[middle]) left = middle+1;else right = middle-1; (2)left和right游标的调整不正确，查找元素为x=a[n-1]时错误。(3)同上，查找元素为x=a[n-1]时错误。(4)left和right游标的调整不正确，查找大于中值的数时可能进入死循环。(5)没什么问题(6)left和right游标的调整不正确，查找元素为x=a[n-1]时错误。(7)left和right游标的调整不正确，查找元素为x=a[0]时错误。2-31234567891011121314template&lt;class T&gt;int binarySearch(T a[], const T &amp;x, int left, int right, int &amp;i, int j) &#123; int middle; while(left&lt;=right)&#123; middle = (left+right)/2; if(x==a[middle])&#123; i=middle;j=middle;return middle; &#125; if(x&gt;a[middle]) left = middle+1; else right = middle-1; &#125; i=right;j=left;return -1; &#125; 2-4当m远小于n时，可以将大整数v分成n/m个长度为m的小段。计算u*v需要计算n/m次m位乘法，每一次m位乘法采用分治法计算，需要$$O(m^{log_23})$$时间。总时间为$$O(\frac{n}{m}m^{log_23})=O(nm^{log_2{\frac{3}{2}}})$$ 算法实现2-6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.FileReader;import java.io.OutputStreamWriter;public class Zidianxu &#123; String input = "/home/wang/input.txt"; String output = "/home/wang/output.txt"; public void write(String string)&#123; //作用就是将传入的字符串写入指定的文件 try &#123; FileOutputStream fileOutputStream = new FileOutputStream(output,false);//覆写模式 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,"UTF-8"); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.write(string); bufferedWriter.flush(); bufferedWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public int jieCheng(int i)&#123; //求阶乘 int result=1; for(int j=2;j&lt;=i;j++)&#123; result*=j; &#125; return result; &#125; public char[] next(char[] s)&#123; //求下一个排列 char[] result=s; int last = s.length-1; for(int i=last-1;i&gt;=0;i--)&#123; if(s[i]&lt;s[last])&#123; //最右边的数，从右往左，遇到第一个比它小的数时， //排列到这个数的前面，这个数以后依次后移一位。 char temp = s[last]; for(int j=last-1;j&gt;=i;j--)&#123; result[j+1] = result[j]; &#125; result[i] = temp; break; &#125; &#125; return result; &#125; public void read()&#123; try &#123; File file = new File(input); BufferedReader reader = new BufferedReader(new FileReader(file)); String string = null,out = ""; int i=0,nums=0,value=0,current=0,nums2=0; //i是行数计数，nums是排列的长度，value是字典序值 //current是当前指向的数字，nums2只是复制一下nums while((string = reader.readLine()) != null)&#123; if(i==0)&#123; nums = Integer.parseInt(string); nums2=nums; &#125; else&#123; //以26458173为例，选定一个数 //看后面有几个比当前数小的，比如2后面比2小的只有1个， //6后面比6小的有4个，4后面比4小的有2个 //8227=1*7!+4*6!+2*5!+... char[] array = string.toCharArray(); for(;current&lt;nums-1;current++)&#123; //从零下标开始依次往后扫描 //counter用来数比这个数小的有几个数 int scan = current+1,counter=0; for(;scan&lt;nums;scan++)&#123; if(array[current]&gt;array[scan])&#123; counter++; &#125; &#125; value+=counter*jieCheng(nums2-1-current); &#125; out+=value+"\n"; char[] result = next(array); String result2 = String.valueOf(result); out+=result2; &#125; i++; &#125; write(out);//写出 reader.close();//关闭BufferedReader &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Zidianxu zidianxu = new Zidianxu(); zidianxu.read(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法作业一]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%B8%80%2F</url>
      <content type="text"><![CDATA[第一次作业71115115 王子卓1-1 求下列函数的渐进表达式$$3n^2 + 10n = O(n^2)$$ $$\frac{n^2}{10} + 2^n = O(2^n)$$ $$21 + \frac{1}{n} = O(1)$$ $$log(n^3) = O(logn)$$ $$10log3^n = O(n)$$ 1-4(1)设在这台新机器上用同一算法在 t 秒内能解规模为$$n_1$$的问题$$32^n64 = 3*2^{n_1}$$ $$n_1 = n + 6$$ (2)设在这台新机器上用同一算法在 t 秒内能解规模为$$n_2$$的问题$$n^2*64 = n_2^2$$ $$n_2 = 8*n$$ (3)T(n) = 8与n无关，所以可以解输入规模任意大的问题。 1-6(1)$$f(n) = logn^2 = 2*logn$$ $$g(n) = logn+5$$ f(n)与g(n)同阶，因此$$f(n) = \theta(g(n))$$ (2)$$f(n) = logn^2 = 2*logn$$ $$g(n) = \sqrt[2]{n} = n^{\frac{1}{2}}$$ $$log_2n$$的反函数为$$2^n$$，而$$\sqrt[2]{n}$$的反函数为$$n^2$$，$$2^n$$的增长速度远高于$$n^2$$，因此$$log_2n$$的增长速度远小于$$\sqrt[2]{n}$$.因此f(n)的阶不高于g(n)的阶，也就是$$f(n) = O(g(n))$$ (3)$$f(n) = n$$ $$g(n) = log^2n$$ $$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(log_2^2n)&lt;O(nlog_2n)$$ $$f(n) = \Omega(g(n))$$ (4)$$f(n) = nlog_2n + n = O(nlog_2n)$$ $$g(n) = log_2n = O(log_2n)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (5)$$f(n) = 10 = O(1)$$ $$g(n) = log10 = O(1)$$ f(n)与g(n)同阶，因此$$f(n) = \theta(g(n))$$ (6)$$f(n) = O(log^2n)$$ $$g(n) = O(logn)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (7)$$f(n) = 2^n = O(2^n)$$ $$g(n) = 100n^2 = O(n^2)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (8)$$f(n) = O(2^n)$$ $$g(n) = O(3^n)$$ f(n)的阶不高于g(n)的阶，因此$$f(n) = O(g(n))$$ 算法实现1-21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package first;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.FileReader;import java.io.OutputStreamWriter;public class ZiDianXuShengXu &#123; int lines=0,count=0; String input = "/home/wang/dict.txt"; String output = "/home/wang/dict2.txt"; public void write(String string)&#123; //作用就是将传入的字符串写入指定的文件 try &#123; FileOutputStream fileOutputStream = new FileOutputStream(output,false);//覆写模式 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,"UTF-8"); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.write(string); bufferedWriter.flush(); bufferedWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void read()&#123; try &#123; File file = new File(input); BufferedReader reader = new BufferedReader(new FileReader(file)); String string = null,out = ""; int i=0,lines=0; while((string = reader.readLine()) != null)&#123; if(i==0) lines = Integer.parseInt(string); //我想了想，好像不需要，所以就没用 else&#123; int sum=0; char temp = string.charAt(string.length()-1);//取出字符串最后一位 sum = temp - 96 - string.length() + 1;//先把最后一位加上 for(int j=0;j&lt;string.length()-1;j++)&#123;//分别计算每一位 temp = string.charAt(j); sum += (temp-96-j)*(26-j);//每一位进制不同 &#125; out+=sum+"\n"; &#125; i++; &#125; write(out);//写出所有的编码 reader.close();//关闭BufferedReader &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ZiDianXuShengXu ziDianXuShengXu = new ZiDianXuShengXu(); ziDianXuShengXu.read(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统实验一]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
      <content type="text"><![CDATA[向Linux内核增加一个系统调用71115115 王子卓 2017年3月14日一.实验目的 通过实验，熟悉Linux操作系统的使用，掌握构建与启动Linux内核的方法；掌握用户程序如何利用系统调用与操作系统内核实现通信的方法，加深对系统调用机制的理解；进一步掌握如何向操作系统内核增加新的系统调用的方法，以扩展操作系统的功能。 二.实验内容 Linux环境下的C或C++编译和调试工具的使用。 向Linux内核增加新的系统调用，系统调用名称和功能自行定义，但必须实现如下输出功能：“My Student No. is 71115115，and My Name is 王子卓”。 Linux新内核的编译、安装和配置。 编写应用程序以测试新的系统调用并输出测试结果。 三.实验步骤 下载Linux内核 1sudo apt install linux-source-4.4.0 下载完的内核放在/usr/src/里，等待解压。 解压内核 12cd /usr/src/sudo tar -xvf ./linux-source-4.4.0.tar.bz2 解压完成之后增添系统调用 增添系统调用 编辑arch/x86/entry/syscalls/syscall_64.tbl 12cd ./linux-source-4.4.0/sudo nano ./arch/x86/entry/syscalls/syscall_64.tbl 我添加了546号系统调用sys_hello 1546 64 hello sys_hello 声明系统函数调用原型 编辑include/linux/syscalls.h 1sudo nano include/linux/syscalls.h 添加系统调用函数原型 1asmlinkage long sys_hello(void); 添加系统调用函数的定义 编辑kernel/sys.c 1sudo nano kernel/sys.c 添加系统调用函数的定义 1234asmlinkage long sys_hello(void)&#123; printk("My student NO. is 71115115, and my name is 王子卓"); return 1;&#125; 编译内核 首先要安装编译所需工具 1sudo apt install libncurses-dev libssl-dev 安装完开始编译内核 1234567sudo make menuconfigsudo make bzImage //在bzImage之前加上 -j2 、 -j4等选项可以选择编译的线程数sudo make modulessudo make modules_installsudo make install //引导自动添加sudo update-grub //保险起见再次更新grub2sudo restart 重启后进入新内核。 测试系统调用 1234567891011//syscall.cpp#include&lt;stdio.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main()&#123; long int call = syscall(546); printf("System call sys_hello returned %ld\n",call); return 0;&#125; 四.主要数据结构及其说明 系统调用表syscall_64.tbl，记录着所有系统调用号。 系统调用头文件syscalls.h，记录着所有系统调用的函数原型。 系统调用定义文件sys.c，记录着所有系统调用的函数实现。 五.程序运行结果 六.实验体会 12345678910111213141516scripts/sign-file.c:23:30: fatal error: openssl/opensslv.h: No such file or directorycompilation terminated.scripts/Makefile.host:91: recipe for target &apos;scripts/sign-file&apos; failedmake[1]: *** [scripts/sign-file] Error 1make[1]: *** Waiting for unfinished jobs.... CC arch/x86/purgatory/purgatory.o AS arch/x86/purgatory/stack.o AS arch/x86/purgatory/setup-x86_64.o CC arch/x86/purgatory/sha256.oMakefile:566: recipe for target &apos;scripts&apos; failedmake: *** [scripts] Error 2make: *** Waiting for unfinished jobs.... AS arch/x86/purgatory/entry64.o CC arch/x86/purgatory/string.o LD arch/x86/purgatory/purgatory.ro BIN2C arch/x86/purgatory/kexec-purgatory.c 这是因为缺少编译所需的libssl-dev库 解决方法：sudo apt install libssl-dev 123456****** Configuration file &quot;.config&quot; not found!****** Please run some configurator (e.g. &quot;make oldconfig&quot; or*** &quot;make menuconfig&quot; or &quot;make xconfig&quot;).*** 这是在编译之前没有执行sudo make menuconfig生成.config文件。 七.源程序123456789101112131415161718192021222324252627sudo nano ./arch/x86/entry/syscalls/syscall_64.tbl//末尾添加546 64 hello sys_hellosudo nano include/linux/syscalls.h//任意位置添加asmlinkage long sys_hello(void);sudo nano kernel/sys.c//任意位置添加asmlinkage long sys_hello(void)&#123; printk("My student NO. is 71115115, and my name is 王子卓"); return 1;&#125;//测试系统调用//syscall.cpp#include&lt;stdio.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main()&#123; long int call = syscall(546); printf("System call sys_hello returned %ld\n",call); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最简单地安装PyQt5+Eric6+Sip+QScintilla2]]></title>
      <url>%2F2017%2F01%2F12%2F%E6%9C%80%E7%AE%80%E5%8D%95%E5%9C%B0%E5%AE%89%E8%A3%85PyQt5-Eric6-Sip-QScintilla2%2F</url>
      <content type="text"><![CDATA[对编译安装说不&emsp;&emsp;编译安装不利于后续升级，也有可能在编译过程中出现各种奇怪的问题，最主要还有对于低端机来说很慢。。。 Ubuntu安装1234567891011sudo apt install python3.5 python3-pip //基础sudo pip3 install qscintilla //这一步会安装PyQt5、Sip、QScintilla2sudo apt install qt4-designer //Eric会用它来创建界面//到官网上下载Eric的压缩包，解压缩，cd到解压目录sudo python3 install.py //安装Eric6sudo python3 install-i18n.py //安装语言包sudo python3 install-debugclients.py //不知道是干嘛的，安装上没坏处sudo pip3 install pyenchant //Python检查拼写的插件，Eric会用上//之后就完成了，比我看到的任何教程都简单。。。//好好研究一下PyQt5吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java大作业说明文档]]></title>
      <url>%2F2017%2F01%2F07%2FJava%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[GitHub ATM机设计文档71115115 王子卓 效果 &emsp;&emsp;服务器的守护进程启动之后可以显示在线人数和各个用户的账户总金额。&emsp;&emsp;ATM机界面在没有登录的时候不可以点击存取款、查询等按钮，金额、编号文本框不可编辑。登陆之后，注册和登录按钮不可点击，用户名、密码文本框不可编辑。 测试方法&emsp;&emsp;修改Server.java中getConnection函数中的dbURL，将&amp;user=root&amp;password=******修改成您的MySQL用户名和密码。 程序结构 &emsp;&emsp;这不是一个标准的UML类图。&emsp;&emsp;活期账户、半年期、一年期、五年期存款和贷款都实现了同一个Balance接口，Balance接口继承了Runnable类。活期账户、半年期、一年期、五年期存款和贷款都聚合到User类中。客户端Client和服务器Server都有User类的成员对象。&emsp;&emsp;客户端Client和服务器守护进程ServerDaemon连接，由ServerDaemon动态创建Server线程。&emsp;&emsp;每一笔存款自身都是线程，服务器打开之后，线程自动运行，实现加息。利息每季度结算，每季度利息是年利率开四次方。&emsp;&emsp;客户端和服务器之间信息传递依靠对象输入输出流，信息载体是Command类对象和User类对象。&emsp;&emsp;数据库的操作由Server类完成。&emsp;&emsp;大部分对象都实现了可序列化Serializable接口，以便存入数据库。&emsp;&emsp;采用了UTF-8编解码，所以支持中文。 数据库结构 数据库名：atm 数据表名：user 数据表字段： name：varchar(200),非空，不可重复 object：longblob，非空 字段作用：name负责存储用户的用户名。object负责存储用户类的对象，该对象中保存有包括用户密码在内的各种用户信息。 优点：在一定程度上减少数据库的读取、写入次数。用户的信息并不以明文方式呈现，在一定程度上有加密的作用。 程序使用流程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AMD New Horizon]]></title>
      <url>%2F2016%2F12%2F17%2FAMD-New-Horizon%2F</url>
      <content type="text"><![CDATA[AMD New Horizon: 打不开点这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第三版)]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%B8%89%E7%89%88%2F</url>
      <content type="text"><![CDATA[综述&emsp;&emsp;广泛意义上讲，代理是一种类，它的作用是作为其他东西的接口。代理可以成为任何东西的接口：网络连接、内存中的大型对象、文件或者是其他不可复制或复制代价很大的资源。简短来说，代理是被客户端调用，用来访问隐藏的实体服务对象的封装类或代理对象。&emsp;&emsp;代理可以简单地直接调用实体对象，也可以添加额外的逻辑。代理可以提供额外的功能，例如对资源敏感的实体对象进行缓存，或者在调用实体对象之前进行前提检查。&emsp;&emsp;对于客户端而言，使用代理对象和使用实体对象是相似的，因为二者都实现了同一个接口。 可能的应用场景远程代理&emsp;&emsp;在分布式对象通信中，本地对象是远程对象的代理对象。本地对象的方法调用的结果是远程对象的方法被调用。典型例子是ATM，ATM持有远程服务器的实体对象的代理对象。 虚拟代理&emsp;&emsp;在一些情况下，用一个大体框架来代替复杂庞大的对象的优势是很明显的。比如当一幅图片很大时用一个虚拟代理替换它，之后按需加载。 保护代理&emsp;&emsp;保护代理被用来基于访问权限，控制资源的访问。 虚拟代理的实例图片接口1234public interface Image &#123; //图片都可以显示 public void displayImage();&#125; 真实图片类12345678910111213141516public class RealImage implements Image &#123; private String filename = null; //真实图片需要加载 public RealImage(final String name) &#123; this.filename = name; loadImageFromDisk(); &#125; //加载方法 private void loadImageFromDisk()&#123; System.out.println("Loading " + filename); &#125; @Override public void displayImage() &#123; System.out.println("Displaying " + filename); &#125;&#125; 代理图片类12345678910111213141516public class ProxyImage implements Image &#123; private RealImage image = null; private String filename = null; public ProxyImage(final String filename) &#123; this.filename = filename; &#125; @Override public void displayImage() &#123; //懒汉式单例:只有在第一次请求实例的时候创建 if (image == null) &#123; image = new RealImage(filename); &#125; image.displayImage(); &#125;&#125; 测试类1234567891011121314public class ProxyTest &#123; public static void main(String[] args) &#123; Image image1 = new ProxyImage("A"); Image image2 = new ProxyImage("B"); image1.displayImage(); image1.displayImage(); image2.displayImage(); image2.displayImage(); //这一次不用再次加载 image1.displayImage(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用阿里云服务器搭建PPTP协议的VPN]]></title>
      <url>%2F2016%2F12%2F13%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAPPTP%E5%8D%8F%E8%AE%AE%E7%9A%84VPN%2F</url>
      <content type="text"><![CDATA[作为运维，我手上现在有一个位于美国硅谷的阿里云ECS服务器。秉承物尽其用的原则，正好搭建一个VPN服务器。 环境介绍 CPU：1核心Haswell架构的处理器 内存：1GB+自己配置的4GB的Swapfile(相当于虚拟内存) 操作系统：Ubuntu14.04LTS 64位 准备工作Linux平台准备12345//安装openssh-clientsudo apt install openssh-client//连接服务器//例如ssh root@127.0.0.1 //ssh 用户名@服务器的公网IP Windows平台准备 安装PuTTY或者XShell，想要更傻瓜操作一点可以安装WinSCP供后续使用 使用PuTTY或者XShell连接服务器 安卓平台准备我就是用我的小米4C上软工课无聊配置得VPN哈哈哈哈，所以我也写一下好了 安装connectBot(详见GitHub) 使用connectBot连接服务器 安装有关软件12//服务器上sudo apt install ppp iptables pptpd 炒鸡简单是吧 更改相关配置更改使用的工具命令行123456vi /file //或者vim//用上下键移动光标到需要修改的那一行，按“i”键进入插入编辑状态，修改完成之后，按“esc”键退出编辑，直接在键盘上输入“:wq&quot;即可保存退出。//好在不一定要用vi/vim，用nano也OKnano /file//上下左右都能移动光标，除了不能用鼠标以外没什么难度。修改完成按Ctrl+X，问是否保存按Y，之后保存名称不用改直接回车。找不到就按Ctrl+W查找就是。 nano的具体操作可以看我使用过的Linux命令之nano - 比vi简单易用的文本编辑器 图形化使用WinSCP以root用户登录，使用WinSCP提供的文本编辑功能双击修改即可。修改完成之后Ctrl+S保存，问你是否覆盖，选是即可。 修改配置文件(以使用nano为例)编辑pptpd.conf1234nano /etc/pptpd.conf//找到#localip 192.168.0.1// #remoteip 192.168.0.234-238,192.168.0.245//删去#号即可 编辑options12345nano /etc/ppp/options//搜索ms-dns，去掉搜索到的两行ms-dns前面的#，并修改为下面的字段//ms-dns 8.8.8.8//ms-dns 8.8.4.4 编辑chap-secrets12345nano /etc/ppp/chap-secrets//添加一行，按照下面格式输入：//用户名 pptpd 密码 *//比如 zizhuo pptpd zizhuo *//*的含义是不限制连接者的IP地址，想要限制的话改成那个IP即可 编辑sysctl.conf(内核文件)1234nano /etc/sysctl.conf//将net.ipv4.ip_forward=0//改成net.ipv4.ip_forward=1 添加iptables转发规则1iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -j MASQUERADE 说明： --table -t table table to manipulate (default: `filter’) --append -A chain Append to chain --source -s address[/mask][…] source specification --out-interface -o output name[+] &emsp;network interface name &emsp;eth1是阿里云服务器的连接外网的网卡，可以用ifconfig看一下哪一块网卡是外网IP就可以 –jump -j target &emsp;&emsp;target for rule (may load target extension) 启动pptpd123sudo service pptpd restart//或者/etc/init.d/pptpd restart 设置开机自启貌似现在默认就可以，不过我还是说一下吧1234//Ubutnu没有chkconfig，可以用rcconfsudo apt install rcconfrcconf on//之后会看到菜单，按空格选择开启/关闭，Tab键跳出选择OK/Cancel 结束去看看所谓的“真实世界”吧2333，下篇文章再见。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[归一化谷歌距离的计算方法]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%BD%92%E4%B8%80%E5%8C%96%E8%B0%B7%E6%AD%8C%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[归一化谷歌距离的计算方法71115115 王子卓 摘要&emsp;&emsp;归一化Google距离（Normalized Google Distance）是一种语义相似性的度量方法，由给定一组关键词集合的Google搜索引擎所返回的命中数量得出。&emsp;&emsp;在自然语言中，具有相同或相似意思的两个关键字在以归一化谷歌距离为单位的情况下趋向于“接近”，意思不同的两个关键字则趋向于“疏远”。本文重点介绍如何使用Java语言和百度搜索引擎实现归一化谷歌距离的计算。&emsp;&emsp;关键字：Normalized Google Distance 、 Java 、百度搜索 1.归一化谷歌距离1.1定义&emsp;&emsp;归一化谷歌距离是以搜索引擎提供的关键字搜索结果数量为计算依据，对语义相似程度的度量方法。&emsp;&emsp;具体而言，两个搜索关键词之间x和y之间的归一化谷歌距离可以用下式表示：&emsp;&emsp;其中：f(x)表示在搜索引擎中搜索x时返回的匹配记录数;f(y)表示在搜索引擎中搜索y时返回的匹配记录数;f(x,y)表示在搜索引擎中搜索词组(x,y)时返回的匹配记录数;M表示搜索引擎总索引量。上式中log均表示自然对数。 1.2分析1.2.1取值范围&emsp;&emsp;NGD(x,y)的取值范围为[0,∞]。如果两个搜索词x和y从未一起出现在同一网页上，而是单独出现时，则他们之间的归一化谷歌距离是无穷。如果两个词总是同时出现，则他们的归一化谷歌距离是0。&emsp;&emsp;一般情况下，NGD(x,y)越接近于0，x、y越相似。如果NGD(x,y)大于等于1，则x、y之间区别很大。&emsp;&emsp;特殊情况下，由于搜索引擎结果不准确，NGD(x,y)可能会小于0。 1.2.2满足规律&emsp;&emsp;在搜索引擎足够准确的情况下 NGD(x,x)等于0，满足同一律。 NGD(x,y)等于NGD(y,x)，满足交换律。 1.2.3尺度不变性&emsp;&emsp;归一化谷歌距离具有尺度不变性。设想如果搜索引擎总的索引量M增长了n倍，那么f(x)、f(y)、f(x,y)也应该增长n倍。这是因为归一化谷歌距离提供给我们搜索关键字之间客观语义联系，当M以一个不确定的比例增长时，NGD(x,y)应该保持稳定。 2.利用百度搜索引擎和Java语言实现谷歌距离的计算2.1设计思路 NormalizedGoogleDistance类 公有静态函数NGD(String a,String b),返回值为Double类型。作用是获取网页的源代码，使用searchResult函数获得三种情况下搜索索引个数，并且将值传递给Calculate函数做计算。 私有静态函数searchResult(String name)，返回值为Double类型。使用正则表达式得到索引个数。 私有静态函数Calculate(Double numA,Double numB,Double numC)，返回值为Double类型。计算并返回归一化谷歌距离的计算结果。 公有静态函数main(String[] args)，返回值为空。接受从命令行传来的两个关键字参数，调用NGD函数计算结果并输出。 2.2具体实现2.2.1主体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.regex.*;public class NormalizedGoogleDistance &#123; static String regex = "百度为您找到相关结果约(.*)个"; static Pattern pattern = Pattern.compile(regex); static String url = "http://www.baidu.com/s?wd="; /** * @param name * @return 搜索到的网页数量 */ private static Double searchResult(String name)&#123; try &#123; URL baiduURL = new URL(url+name); URLConnection connection = baiduURL.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); //逐行筛选匹配正则表达式，并将结果中的逗号删除，之后转化成数字。 String html = in.readLine(); while(html!=null)&#123; Matcher matcher = pattern.matcher(html); while(matcher.find())&#123; System.out.println(name.replaceAll("%20", " ")+": "+matcher.group(1));//格式优化 String temp = matcher.group(1); return Double.parseDouble(temp.replaceAll(",", "")); &#125; html = in.readLine(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0.0;//有可能没有返回值，所以默认写一个0.0 &#125; /** * @param a * @param b * @return The result of NGD */ public static Double NGD(String a,String b)&#123; //删去空格，以防搜索出错 a=a.replaceAll(" ", ""); b=b.replaceAll(" ", ""); //正则表达式匹配个数 //用于存三次搜索各自的索引量 Double numA,numB,numC; numA=1.0;numB=1.0;numC=1.0; try &#123; numA = searchResult(a); numB = searchResult(b); numC = searchResult(a+"%20"+b); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //返回Calculate函数的计算结果 return Calculate(numA, numB, numC); &#125; /** * @param numA * @param numB * @param numC * @return NGD公式计算结果 */ public static Double Calculate(Double numA,Double numB,Double numC)&#123; Double lnx = Math.log(numA); Double lny = Math.log(numB); Double lnSum = Math.log(25270000000.0);//由于不知具体数值，这里取谷歌搜素最大索引限制 Double lnxy = Math.log(numC); //NGD公式 if (lnx&gt;lny) &#123; return (lnx-lnxy)/(lnSum-lny); &#125;else &#123; return (lny-lnxy)/(lnSum-lnx); &#125; &#125; /** * @param args * 从外部传进两个参数作为关键字，并将结果输出 */ public static void main(String[] args) &#123; Double result = NGD(args[0], args[1]); System.out.println("NGD: "+result); &#125;&#125; 2.2.2界面实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.GridLayout;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.UIManager;public class NGDUI &#123; public NGDUI() &#123; //初始化应用标题和标签 JFrame frame = new JFrame("Normalized Google Distance"); JLabel label1 = new JLabel("参数一"); JLabel label2 = new JLabel("参数二"); JLabel label3 = new JLabel("结果"); //三行一列的网格布局 frame.setLayout(new GridLayout(3, 1)); //第一行流式布局 JPanel panel1 = new JPanel(); panel1.setLayout(new FlowLayout()); panel1.add(label1); JTextField textField1 = new JTextField(20); panel1.add(textField1); //第二行流式布局 JPanel panel2 = new JPanel(); panel2.setLayout(new FlowLayout()); panel2.add(label2); JTextField textField2 = new JTextField(20); panel2.add(textField2); //第三行流式布局 JPanel panel3 = new JPanel(); panel3.setLayout(new FlowLayout()); panel3.add(label3); JTextField textField3 = new JTextField(20); textField3.setEditable(false);//结果框不可更改 panel3.add(textField3); JButton query = new JButton("查询");//查询按钮 //给查询按钮加上事件监听器 query.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; textField3.setText(String.valueOf( NormalizedGoogleDistance.NGD( textField1.getText(),textField2.getText() ))); &#125; &#125;); panel3.add(query); frame.setSize(300, 300); //设置窗口居中 Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize(); frame.setLocation((dimension.width-frame.getWidth())/2, (dimension.height-frame.getHeight())/2); //添加到网格布局中 frame.add(panel1);frame.add(panel2);frame.add(panel3); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); frame.setResizable(false); &#125; public static void main(String[] args) &#123; try &#123; //设置皮肤 UIManager.setLookAndFeel("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel"); NGDUI ui = new NGDUI(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考文献【1】RudiL.Cilibrasi and PaulM.B.Vitanyi. The Google Similarity Distance 【J】IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, VOL.19, NO3, MARCH2007, P370–383【2】张玉芳,艾东梅,黄 涛,熊忠阳.结合编辑距离和Google距离的语义标注方法 【A】计算机应用研究，2010年2月，第二期，第二十七卷【3】匿名. Normalized Google distance，维基百科，https://en.wikipedia.org/wiki/Normalized_Google_distance【4】pinyangtenglong的专栏. 归一化Google距离（Normalized Google Distance），CSDN博客，http://blog.csdn.net/pinyangtenglong/article/details/26963015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第二版)]]></title>
      <url>%2F2016%2F12%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E7%89%88%2F</url>
      <content type="text"><![CDATA[之前的例子可能不太恰当，于是我就又想了一个例子。 定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 大体思路 德云社有很多分社，遍布大江南北。人们每每提到德云社，总是对一种剧场的总称。因此德云社是一种接口。它有enter进入方法。 南京德云社是全国的德云社之一，每当有人enter进入就会提示。 售票员Conductor也是德云社一员，他可以是任何德云社的售票员。售票员会提前咨询场馆有多少座位，max由剧场座位数seats决定。超过max人就禁止观众进入。 观众Audience都有名字，可以进入任意的德云社。观众必须经过售票员，售票员是哪个德云社的代理，观众就进入哪一个。 UML类图 实际代码德云社接口1234public interface DeYunShe &#123; void enter(Audience audience); int getSeats();&#125; 南京德云社123456789101112public class NanJingDeYunShe implements DeYunShe &#123; public static final int seats=3; @Override public void enter(Audience audience) &#123; System.out.println(audience.getName()+" entered!"); &#125; @Override public int getSeats() &#123; return seats; &#125;&#125; 售票员1234567891011121314151617181920212223242526public class Conductor implements DeYunShe &#123; private int max=0; private int audiences=0; private DeYunShe dys; public Conductor(DeYunShe dys) &#123; this.dys = dys; &#125; @Override public int getSeats() &#123; max = dys.getSeats(); return 0; &#125; @Override public void enter(Audience audience) &#123; if (audiences&lt;max) &#123; dys.enter(audience); audiences++; &#125;else &#123; System.out.println(audience.getName()+" is not allowed to enter!"); &#125; &#125;&#125; 观众123456789public class Audience &#123; private String name; public Audience(String n) &#123; name = n; &#125; public String getName()&#123; return name; &#125;&#125; 测试123456789public class Test &#123; public static void main(String[] args) &#123; Conductor proxy = new Conductor(new NanJingDeYunShe()); for(int i=1;i&lt;=5;i++)&#123; proxy.enter(new Audience("Audience"+i)); &#125; &#125;&#125; 运行结果 实验请将本例补充完整，并且增加北京德云社，让这个售票员做它的代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[太平歌词白蛇传]]></title>
      <url>%2F2016%2F12%2F04%2F%E5%A4%AA%E5%B9%B3%E6%AD%8C%E8%AF%8D%E7%99%BD%E8%9B%87%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[太平歌词白蛇传唱词个人整理 我认为应该这样停顿，就简单的画了一下 我爱这门艺术，不希望它完了 杭州/美景/盖世无双西湖岸/奇花异草/四（了）季（个）清香春游/苏堤/桃红柳绿那夏赏/荷花/映满了池塘这秋观/明月/如同碧水冬看/瑞雪/铺满了山岗我表的是/峨眉山白蛇下界在这上天/怒恼了张玉皇怒冲冲/差法海/临了凡界在这金山/寺内把这方丈当这一天/许汉文/烧香还愿老法海/拦去路/有语开腔我算定/你的妻/多了年的怪蟒缠绕你/结连理/盗取真阳有许仙/闻此言/魂飞魄散留在了/文殊院/未转钱塘青白蛇/一怒就找到了寺院那手指/山门骂和尚放出来/儿夫还则罢了若不然/青锋剑下秃头命亡众僧人/急忙忙/把这山门关上那抱头/鼠窜/往内藏小青儿/拘来了/这个虾兵蟹将众水族/显神通/水淹佛堂老法海/坐在了莲台/掐诀念咒那水也涨/庙也长/漫不了山墙钱塘县的/众黎民/遭了涂炭数十万/生灵在水内亡半悬空/又来了/天兵天将那金吒木吒哪吒太子/托塔的天王四值/功曹/二十八宿那梅山/六将/灌口的杨二郎李天王/一怒就祭起了宝塔脸森森/要把这白蛇来伤魁星爷/发恻隐/放她逃走只因她/腹内怀有状元郎老法海唤过了许仙/开言道我赐你/佛钵/去把妖降许汉文/接过了佛钵/心肠硬扭回/头来/够奔了钱塘在这一(呀)路上/点点/飘散/桃杏雨潇潇/不断/柳风扬顾不得/连理枝儿/狂风吹散顾不得/比翼鸟儿/棍下伤亡玉碎/珠沉人何在(哎这)镜花/水月两分张穿大街/过小巷/来的多么快启珠帘/走进来这负心郎白娘子/见佛钵/得得得得颤战兢兢/玉体/粉了面的娇惶尊丈夫/高抬手/把奴容让止不住/秋波儿/泪(了)洒胸膛曾记得/游湖借伞百般恩爱曾记得/那红罗帐下/会鸳鸯那五月/初五/端阳日大不该/夫妻对坐饮雄黄三杯酒/下咽喉/醉倒在绡金帐(嘞嘿)现原形/吓得儿夫/命见阎王奴为你/长寿山/盗来了还阳草还与那/守山的神将/是大战了一场多亏了/寿星爷/发了恻隐赠了那/保命丹/我这转回了家乡我进门来呀/用金丹那/撬牙关/把这金丹灌下搭救/儿夫你转还阳我只说/到金山/你是烧香还愿有谁知/飞灾横祸落在身旁到如今你手托佛钵/回家转口口/声声要把妖降看起来/红颜薄命/真命苦空叫我/眼泪流干/寸断了肝肠奴好比/月当空被这乌云遮上奴好比/瓦上霜我是难见日光奴好比/弓断弦我是回天无术奴好比/泥牛入海隐入汪洋我这看起来/人生苦短无药救不由得/两泪流干散落胸膛忙把娇儿怀中抱为娘我/有句话/细听端详再吃口/为娘断肠的乳从今/往后离了亲娘埋怨/休把娘埋怨埋怨/你父丧尽了天良回头来/忙把这青儿叫你与我/扶养这小儿郎忙把娇儿递过去这刷拉拉/佛钵放了豪光白娘子/压在了这雷峰塔终朝每日/受凄凉好可叹/十八年/灾数才满许梦娇/中状元/雷峰塔下见了亲娘我一言/唱不尽这白蛇传/我是愿诸位/合家欢乐是福寿绵长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式]]></title>
      <url>%2F2016%2F11%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 UML 角色及职责 Subject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。 Proxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后工作。 应用场景举例(老司机发车咯)代理模式好有一比。比从何来？好比西门庆找潘金莲，让王婆做代理。(营养跟不上的请自觉下车233)首先，我们先定义这种女人。一种类型嘛，肯定要是接口12345678public interface KindWoman &#123; //这种女人能做什么事情呢？ public void makeEyesWithMan();//抛媚眼 public void happyWithMan();//你懂得 &#125; 之后，我们要有潘金莲 1234567891011121314public class PanJinLian implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("潘金莲和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("潘金莲抛媚眼..."); &#125;&#125; 然后王婆登场 123456789101112131415161718192021222324252627public class WangPo implements KindWoman &#123; private KindWoman kindWoman; public WangPo()&#123; //默认的话是潘金莲的代理 this.kindWoman = new PanJinLian(); &#125; //她可以是KindWoman的任何一个女人的代理，只要你是这一类型 public WangPo(KindWoman kindWoman)&#123; this.kindWoman = kindWoman; &#125; @Override public void happyWithMan() &#123; //自己老了，但可以叫年轻的代替。 this.kindWoman.happyWithMan(); &#125; @Override public void makeEyesWithMan() &#123; //王婆年纪大了，谁看她抛媚眼啊 this.kindWoman.makeEyesWithMan(); &#125;&#125; 女主角都上场了，接下来该男主角西门大官人了 123456789101112131415161718192021/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); &#125;&#125; 之后再来个玉堂春吧233，虽然不是一个时代(详见《三堂会审玉堂春》)。 1234567891011121314public class YuTangChun implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("玉堂春和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("玉堂春抛媚眼..."); &#125;&#125; 这之后，西门庆可以勾搭玉堂春123456789101112131415161718192021222324252627/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有，表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); //西门庆勾搭玉堂春 YuTangChun yuTangChun = new YuTangChun(); wangPo = new WangPo(yuTangChun); wangPo.makeEyesWithMan(); wangPo.happyWithMan(); &#125;&#125; 故事背后深层含义(车到站了哦)代理模式主要使用了java的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚得很，同样一个接口呗。今天老司机就开到这里吧，红红火火恍恍惚惚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线索二叉树的遍历方法]]></title>
      <url>%2F2016%2F11%2F22%2F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[求各种次序线索树非叶子结点的前驱和后继的方法： 前序线索树非叶子结点p的前驱：p的双亲结点； 前序线索树非叶子结点p的后继：若p有左孩子，则后继为其左孩子，否则后继是其右孩子。 后序线索树非叶子结点p的前驱：若p有右孩子，则后继为其右孩子；否则后继是其左孩子。 后序线索树非叶子结点p的后继：若p为根结点，则其后继为空；若p为其双亲结点的右孩子，或p为左孩子且其双亲结点无右孩子，则p的后继为其双亲结点； 若p为左孩子，且其双亲结点有右孩子，则其后继为双亲结点右子树的第一个结点（最左边结点）。 中序线索树非叶子结点p的前驱：左子树的最后一个结点（最右边的结点）。 中序线索树非叶子结点p的后继：右子树的第一个结点（最左边结点）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Umbrello UML 文档个人翻译]]></title>
      <url>%2F2016%2F11%2F01%2FUmbrello-UML-%E6%96%87%E6%A1%A3%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91%2F</url>
      <content type="text"><![CDATA[只是关于UML基础知识部分的翻译 UML基础关于UML这一章节会给你一个UML基础知识的概览。一定要记住，这不是一个综合的UML教程，而只是一个可以当做UML教程的对UML的简要介绍。统一建模语言(UML)是一个图表语言，或者说是用来指定、可视化和文档化面向对象软件的模型的标记法。UML不是一种开发方法，这也就意味着它不会一五一十地告诉你每一步要做什么和如何设计你的系统，但是它可以帮助你可视化你的设计和与他人沟通。UML为面向对象程序设计而生，对其他编程模式作用有限。UML由许多模板元素组成，这些模板元素代表着软件系统的不同部分。UML的元素被用来创建示意图，这些示意图代表着一个软件系统的一部分或者一个方面。Umbrello支持以下的这些表： 用例图：展示演员（系统的用户）、用例（用户使用系统的情形）以及他们之间的关系。 类图：展示类和他们之间的关系。 顺序图：展示对象以及一系列的对象对其他对象的方法调用。 协作图：展示对象和他们之间的关系，重点强调参与信息传递的对象。 状态图：展示状态、状态变化以及对象或一部分系统中的事件。 活动图：展示活动以及伴随着部分系统的事件而产生的活动改变。 组件图：展示高级编程组件。比如KParts和Java Beans 配置图：展示组件的实例和它们之间的关系。 实体关系图：展示数据、关系以及数据之间的约束。 UML元素用例图用例图描述一组用例以及参与这个过程的演员之间的关系和依赖。 一定要注意，用例图不适合描述设计，也不能描述系统的内部。用例图是为简化与未来的系统用户、顾客的交流而生的，对决定系统的需求有很大帮助。用例图可以说明系统是做什么的，但是不会也不能确定如何去做。 用例用例站在演员的角度描述一组系统中的产生确定结果的活动。用例是系统中成员和系统自身的特殊互动的描述。它们代表系统的外部接口，并且指定系统要做什么。 使用用例的时候，一定要注意以下几点： 每一个用例至少和一位演员关联 每一个用例都有一个发起人 每一个用例都会产生相关结果 用例之间也可以有联系，其中有三种联系最为典型： &lt;&lt;include&gt;&gt;指一个用例发生在另一个用例之中 &lt;&lt;extends&gt;&gt;指在某些情况或者某些点（扩展点），一个用例被另一个扩展 Generalization指一个用例继承一个“高级”用例的特性，可以像类继承一样覆盖或者添加特性 演员演员是系统之外的实体，他们以参与用例的方式与系统交互。他们可以是人、其他电脑系统或者外部事件。 演员不代表实体人或者系统，而是角色。也就是说一个人在做不同操作时可以是不同的演员。 用例描述用例描述是用例的文本描述，通常以连接用例的笔记或文档的形式，解释发生在用例中的过程或活动。 类图类图展示组成系统的不同类以及它们之间关联的方式。类图是静态图表，因为虽然它展示了类之间的关系，但是没有展示它们之间的调用方法。 类一个类定义了一组对象的属性和方法。所有这个类的对象共享同样的行为，具有同种属性（各有各的值）。类和类型不一样，类型意思更广泛。 在UML中，矩形代表类，分为三个部分，分别写有类名、属性（成员变量）、操作（函数、方法）。 属性在UML中，属性最少要展示它们的名字，也可以展示它们的类型、初值等其他属性。属性也可以展示它们的可见度： +代表公有属性（public） #代表保护属性（protected） -代表私有属性（private） 操作操作（方法）也是最少要展示它们的名字，还可以展示它们的参数列表和返回值。像属性一样，操作也可以展示他们的可见度： +代表公有操作（public） #代表保护操作（protected） -代表私有操作（private） 模板类里面可以有模板，它是一个未指定的类或类型。模板在类初始化的时候特化（比如一个对象生成时）。模板存在于现代C++以及Java1.5以后的版本（称为泛型） 类之间的联系类之间可以有多种联系： 泛化继承是面向对象编程的基本概念。子类可以获得父类的所有属性和操作，也可以覆盖或修改其中的一部分，还可以添加自己的属性和操作。 在UML中，两个类之间的泛化联系分层展示了基类和派生类之间的继承关系。在UML中，泛化由连接两个类的直线和指向基类的箭头表示。 关联关联是类之间的一种关系，给出一般语义和结构用来说明对象之间的多种”联系”方式。 关联是对象之间的交流机制，它描述了不同类之间的关系（实体对象之间的联系称为object connection，也叫链接（link））。 关联可以在特化联系的目的中起作用，可以是单向的也可以是双向的(indicates if the two objects participating in the relationship can send messages to the other, of if only one of them knows about the other)。 关联的两端各有一个数值，它们规定了关联一端的一个对象能和另一端的多少对象联系。 在UML中，关联被表示成连接具有关联关系的两个类的直线，它也可以展示参与者的角色以及数量。数量被表示成非负数的一个范围[min..max]，如果max一端是*，则代表无穷。 聚合聚合是两个不等权参与类之间的特殊联系。两个参与类之间构成”整体-部分”关系。聚合关系描述”整体类”是如何由”部分类”构成的。对于聚合关系来说，”整体类”数量永远只能为1。 在UML中，聚合由”整体类”一侧有空心菱形的直线来表示。 组合组合是一种非常强的聚合。组合中的”部分类”只能依存于”整体类”而存在。整体消亡则部分消亡。比如书和书中的章节。 在UML中，组合由”整体类”一侧有实心菱形的直线来表示。 其他类图组件类图中除了类还有其他的组件。 接口借口是抽象的类，不能直接产生实例。它们可以包含操作，但是不能包含属性。类可以继承与实现接口，之后产生实例。 数据类型数据类型是编程语言内置的基元，比如整形数和布尔型数。它们不能与类关联，但是类可以与它们关联。 枚举枚举是值的简单列表，比如一周七天。枚举的选项称为枚举常量。像数据类型一样，它们不能与类关联，但是类可以与它们关联。 包包代表编程语言中的命名空间。在图表中它们被用来表示系统的一部分。它可以包含多个甚至上百个类。 顺序图顺序图展示了指定时间界限内多个对象之间的信息交换。对象是类的实例。顺序图特别强调了对象发送信息的顺序和时间。 在顺序图中，垂直的虚线代表对象，并且对象的名字写在最上端。时间轴也是垂直的，越向下时间越晚。因此信息在对象间以带有操作和参数的箭头的形式传递。 消息可以是同步的，那种普通的信息调用，这时控制权被传递给被调用的对象直到方法结束。也可以是异步的，控制权一直在主调对象。同步消息在被调对象那里有一个垂直的方框，用来展示程序控制流。 协作图协作图展示参与特定事件的对象之间的互动。协作图展示的信息或多或少的与顺序图有相似之处，但是顺序图更加侧重于强调互动何时发生，而协作图突出对象之间的关系和拓扑结构。 在协作图当中，对象之间的信息传递用箭头表示，展现了信息的名称、参数以及信息的顺序。协作图非常适合展示一个特定的程序流或者情形，而且它还是最好的说明或解释程序逻辑的一个过程的图表之一。 状态机图状态图展示一个对象生命周期中的不同状态以及使对象改变状态的刺激(stimuli)。 状态机图将对象看作状态机(state machines)或者有限的自动化，它可以处于有限多个状态中的一个状态，并且可以因为有限多种状态之中的一种而改变它的状态。比如说一个网络服务器类型的对象在它的生命周期中可以有以下状态： 就绪 监听 运行 停止 可以让它改变状态的事件有： 对象被创建 对象收到监听信息 有客户端通过网络请求连接 有客户端终止请求 请求被执行并且结束 对象收到停止信息 …… 状态状态是状态机图的砖瓦。一个状态确定的属于一个类，它代表了一个类的属性的值的集合。一个UML状态描述了一个特定的类的一个对象的内部状态。 要注意，不是每一个对象属性的变化都应该用状态表示，只有明显影响对象的工作状态的变化才用状态表示。 有两种状态是特殊的：开始和结束。之所以说它们特殊，是因为没有任何事件可以让对象返回初始状态或离开结束状态。 活动图活动图描述系统中活动的顺序,是一种只含有活动或者大部分是活动，特殊类型的状态机图。 活动图比较类似于程序流图，不同在于所有的活动都清楚地与对象连接。 活动图永远和类、操作或用例相关联。 活动图支持顺序和并行的活动。 活动一个活动是一个流程中的一步。一个活动是系统的一个状态，它带有内部的活动以及至少一个的外部转换(outgoing transition)。如果存在不同的情况，活动也可以有多个外部转换。 活动也可以有层次结构。活动需要体现子图的向内向外转换。（an Activity can be composed of several ‘detail’ Activities, in which case the incoming and outgoing transitions should match the incoming and outgoing transitions of the detail diagram.）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(3) chgrp]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-3-chgrp%2F</url>
      <content type="text"><![CDATA[Linux chgrp命令Linux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...] 参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 实例实例1：改变文件的群组属性：chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log [root@localhost test]# chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 说明： 将log2012.log文件由root群组改为bin群组 实例2：根据指定文件改变文件的群组属性chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root root 61 11-13 06:03 log2013.log [root@localhost test]# chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log 说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(2) chattr]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-2-chattr%2F</url>
      <content type="text"><![CDATA[Linux命令(2) chattrLinux chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途。即append,设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件，只有root才能设定这个属性。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 语法chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...] 参数 -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 实例用chattr命令防止系统中某个关键文件被修改：chattr +i /etc/resolv.conflsattr /etc/resolv.conf会显示如下属性----i-------- /etc/resolv.conf 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：chattr +a /var/log/messages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(1) cat]]></title>
      <url>%2F2016%2F10%2F28%2FLinux%E5%91%BD%E4%BB%A4-1-cat%2F</url>
      <content type="text"><![CDATA[Linux命令(1) catcat命令用于把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案) 使用权限所有用户 语法格式cat [-AbeEnstTuv] [--help] [--version] fileName 参数说明 -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 实例说明把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -n textfile1 &gt; textfile2 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。cat -b textfile1 textfile2 &gt;&gt; textfile3 清空/etc/test.txt档案内容cat /dev/null &gt; /etc/test.txt cat 也可以用来制作镜像文件。例如要制作软碟的像文件，将软碟放好后输入cat /dev/fd0 &gt; OUTFILE 相反的，如果想把 image file 写到软碟，请输入cat IMG_FILE &gt; /dev/fd0 备注 OUTFILE 指输出的镜像文件名。 IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用在制作开机磁片。]]></content>
    </entry>

    
  
  
</search>
