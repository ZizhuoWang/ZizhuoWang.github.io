<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F11%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E6%80%BB%E7%BB%93%E5%89%8D%E4%B8%89%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[概率论总结.mdhtml {overflow-x: initial !important;}html { font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { background: rgb(181, 214, 252); text-shadow: none; } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } .typora-export #write { margin: 0px auto; } #write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; } #write li > table:first-child { margin-top: -20px; } img { max-width: 100%; vertical-align: middle; } input, button, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; } input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; } ::before, ::after, * { box-sizing: border-box; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; } .mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-radius: 4px; } #write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 80px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } pre { white-space: pre-wrap; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } .md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; } .md-fences.mock-cm { white-space: pre-wrap; } .show-fences-line-number .md-fences { padding-left: 0px; } .show-fences-line-number .md-fences.mock-cm { padding-left: 40px; } .footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; } .footnotes + .footnotes { margin-top: -1em; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: transparent; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li p, li .mathjax-block { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; } @media print { html, body { height: 100%; } .typora-export * { -webkit-print-color-adjust: exact; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; } p { orphans: 4; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 1cm; padding-right: 1cm; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0mm; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p .md-image:only-child { display: inline-block; width: 100%; text-align: center; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .mathjax-block { white-space: pre; overflow: hidden; width: 100%; } p + .mathjax-block { margin-top: -1.143rem; } .mathjax-block:not(:empty)::after { display: none; } [contenteditable="true"]:active, [contenteditable="true"]:focus { outline: none; box-shadow: none; } .task-list { list-style-type: none; } .task-list-item { position: relative; padding-left: 1em; } .task-list-item input { position: absolute; top: 0px; left: 0px; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc::after, .md-toc-content::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); text-decoration: none; } .md-toc-inner:hover { } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: "."; } .md-tag { opacity: 0.5; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: monospace; } code { text-align: left; } h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; } a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; background: transparent !important; text-decoration: initial !important; text-shadow: initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: monospace; } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { transition: none; } @font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); } @font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); } @font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); } @font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); } html { font-size: 16px; } body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; } #write > ul:first-child, #write > ol:first-child { margin-top: 30px; } body > :first-child { margin-top: 0px !important; } body > :last-child { margin-bottom: 0px !important; } a { color: rgb(65, 131, 196); } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); } h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: rgb(119, 119, 119); } p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; } li > ol, li > ul { margin: 0px; } hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border-width: 0px 0px 1px; border-style: none none solid; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); } body > h2:first-child { margin-top: 0px; padding-top: 0px; } body > h1:first-child { margin-top: 0px; padding-top: 0px; } body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; } body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; } h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0px; } ul:last-child, ol:last-child { margin-bottom: 0px; } blockquote { border-left: 4px solid rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); } blockquote blockquote { padding-right: 0px; } table { padding: 0px; word-break: initial; } table tr { border-top: 1px solid rgb(204, 204, 204); background-color: white; margin: 0px; padding: 0px; } table tr:nth-child(2n) { background-color: rgb(248, 248, 248); } table tr th { font-weight: bold; border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; } table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0px; } table tr th:last-child, table tr td:last-child { margin-bottom: 0px; } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); } .md-fences, code, tt { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; } .task-list { padding-left: 0px; } .task-list-item { padding-left: 32px; } .task-list-item input { top: 3px; left: 8px; } @media screen and (min-width: 914px) { } @media print { html { font-size: 13px; } table, pre { break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: rgb(248, 248, 248); } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; } .mathjax-block > .code-tooltip { bottom: 0.375rem; } #write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; } #write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; } .md-image > .md-meta { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; } .md-tag { color: inherit; } .md-toc { margin-top: 20px; padding-bottom: 20px; } #typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); } #typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; } #md-notification::before { top: 10px; } .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.117647); } header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; } 第一章 随机事件和概率1.1 事件、样本空间、事件间的关系与运算1.1.1 随机试验对随机现象进行观察或实验成为随机试验，简称试验，记作E，它具有如下特点：可以在相同条件下重复进行。所得的结果可能不止一个，且所有可能结果都能事前已知。每次具体实验之前无法预知会出现哪个结果。1.1.2 样本空间随机试验的每一可能结果称为样本点，记作\omega.由所有样本点全体组成的集合称为样本空间，记作\Omega.​ 样本点是组成样本空间的元素，样本空间是样本点的全集，样本空间有以下三种类型：有限集合：样本空间中的样本点个数是有限的。无限可列集合：样本空间中的样本点个数是无限的，但是可以列出来。无限不可列集合：样本空间中的样本点个数是无限的，而且不能列出来。1.1.3 随机事件样本空间的子集称为随机事件，简称事件，常用字母A,B,C等表示​ 随机事件是由样本空间中的元素即样本点组成，由一个样本点组成的子集是最简单事件，称为基本事件。随机事件既然由样本点组成，那么也可以认为随机事件是由基本事件组成。​ 如果一次试验的结果为某一基本事件出现，就称该基本事件出现或发生。如果组成事件A的一个基本事件出现或发生，也称事件A出现或发生。​ 把\Omega看成一个事件，则每次试验必有\Omega中某一基本事件发生，也就是每次试验\Omega必然发生，称\Omega为必然事件。​ 把不包含任何样本点的空集\phi看成一个事件，则每次试验\phi必不发生，称\phi为不可能事件。1.1.4 事件的包含如果事件A发生必然导致事件B发生，则称事件B包含事件A，或称事件A包含于事件B，记为B \supset A或A \subset B.​ 从集合关系来说，事件A的每一个样本点都属于事件B。1.1.5 事件的相等如果A \supset B和B \supset A同时成立，则称事件A与事件B相等。1.1.6 事件的交如果事件A与事件B同时发生，则称这样的一个事件为事件A与事件B的交或积，记为A \cap B或AB​ 集合A\cap B是由同时属于A与B的所有公共样本点构成。​ 事件的交可以推广到有限多个事件或可数无穷多个事件的情形： \bigcap_{i=1}^{n}A_{i} = A_1 \cap A_2 \cap \cdots \cap A_n \\ \bigcap_{i=1}^{+ \infty}A_i = A_1 \cap A_2 \cap \cdots \cap A_n \cap \cdots 1.1.7 互斥事件如果事件A与事件B的关系为AB=\phi，即A与B不能同时发生，则称事件A与事件B为互斥或互不相容。​ 互斥的两个事件没有公共样本点。​ 事件的互斥可以推广到有限多个事件或可数无穷多个事件的情形：​ 若n个事件A_1,A_2,A_3\cdots,A_n中任意两个事件均互斥，则称这n个事件两两互斥或两两互不相容。​ 若可数无穷多个事件A_1,A_2,A_3\cdots,A_n,\cdots中任意两个事件均互斥，则称这可数无穷多个事件两两互斥或两两互不相容。1.1.8 事件的并如果事件A与事件B至少有一个发生，则称这样一个事件为事件A与事件B的并或者和，记为A \cup B​ 集合A\cup B是由属于A与B的所有样本点构成。​ 事件的并可推广到有限多个事件或可数无穷多个事件的情形： \bigcup_{i=1}^{n}A_i = A_1 \cup A_2 \cup \cdots A_n \\ \bigcup_{i=1}^{+\infty}A_i = A_1 \cup A_2 \cup \cdots A_n \cup \cdots 1.1.9 对立事件如果事件A与事件B有且仅有一个发生，即同时成立A \cup B = \Omega和A \cap B = \phi，则称事件A与事件B为对立事件或互逆事件，记为\overline{A} = B或\overline{B} = A.1.1.10 事件的差事件A发生而事件B不发生称为事件A与事件B的差，记为A-B.​ 在样本空间中的集合A-B是由属于事件A而不属于事件B的所有样本点构成的集合。​ 显然A-B = A \overline{B}.1.1.11 事件的运算规律交换律 A \cup B = B \cup A , A \cap B = B \cap A结合律 A \cup (B \cup C) = (A \cup B) \cup C \\ A \cap (B \cap C) = (A \cap B) \cap C分配律 A \cap (B \cup C) = (A \cap B) \cup (A \cap C) \\ A \cup (B \cap C) = (A \cup B) \cap (A \cup C)对偶律 \overline{A \cup B} = \overline{A} \cap \overline{B} , \overline{A \cap B} = \overline{A} \cup \overline{B} \\ \overline{\bigcup_{i=1}^{n}} = \bigcap_{i=1}^{n} \overline{A_i} , \overline{\bigcap_{i=1}^{n}} = \bigcup_{i=1}^{n} \overline{A_i}1.2 概率、条件概率、独立性和五大公式1.2.1 概率公理​ 设试验E的样本空间为\Omega，称实值函数P为概率，如果P满足如下三个条件：对于任意事件A，有P(A) \ge 0对于必然事件\Omega，有P(A) = A对于两两互斥的可数无穷多个事件A_1 , A_2 , \cdots , A_n , \cdots 有P(A_1 \cup A_2 \cup \cdots \cup A_n \cup \cdots) = P(A_1) + P(A_2) + \cdots + P(A_n) + \cdots ，称P(A)为事件A的概率。1.2.2 条件概率设A , B为两个事件，且P(A)>0，称 P(B | A) = \frac{P(AB)}{P(A)} 为在事件A发生的条件下，事件B发生的条件概率。1.2.3 概率的性质P(\phi) = 00 \le P(A) \le 1P(\overline{A}) = 1 - P(A) A \subset B，则P(A) \le P(B)对于两两互斥的有限个事件A_1, A_2, \cdots, A_n，有 P(A_1 \cup A_2 \cup \cdots \cup A_n) = P(A_1) + P(A_2) + \cdots + P(A_n) 1.2.4 事件独立性设A,B两事件满足等式 P(AB) = P(A)P(B) 则称A与B相互独立。​ 设A_1, A_2, \cdots, A_n是n个事件，如果对于任意k(1 < k < n)，任意1 \le i_1< i_2< \cdots< i_k \le n满足等式 P(A_1 A_2 \cdots A_k) = P(A_1)P(A_2) \cdots P(A_k) ​ 则称A_1, A_2, \cdots , A_n为相互独立的事件。【注】：n个事件相互独立需要个等式成立 C_n^2+C_n^3+\cdots+C_n^n = 2^n-n-1个等式成立 1.2.5 相互独立的性质A与B相互独立的充要条件是与或与或与A与\overline{B}或\overline{A}与B或\overline{A}与\overline{B}相互独立。当00时，P（A_1)P(A_2|A_1) \cdots P(A_n|A_1A_2 \cdots A_n) 全概率公式设满足且对于任意事件有称满足的为的一个完备事件组 设B_1, B_2, \cdots , B_n满足 \bigcup_{i=1}^{n} B_i = \Omega , B_iB_j = \phi(i \neq j)且P(B_k)>0, k=1,2,\cdots ,n, \\ 对于任意事件A有 \\ P(A) = \sum_{i=1}^{n}P(B_i)P(A|B_i) \\ 称满足 \bigcup_{i=1}^{n} B_i = \Omega , B_iB_j = \phi(i \neq j)的B_1, B_2, \cdots , B_n为\Omega的一个完备事件组 贝叶斯公式设B_1, B_2, \cdots , B_n满足且 \bigcup_{i=1}^{n} B_i = \Omega, B_iB_j = \phi (i \neq j)且P(A)>0,P(B_k)>0,k=0,1,2, \cdots , n ​ 则 P(B_j|A) = \frac{P(B_j)P(A|B_j)}{\sum_{i=1}^{n}P(B_j)P(A|B_j)} \ , j=1,2, \cdots ,n 1.3 古典概型与伯努利概型1.3.1 古典型概率当试验结果为有限n个样本点，且每个样本点的发生具有相等的可能性，如果事件A由n_A个样本点组成，则事件A的概率为所包含的样本点数样本点总数 P(A) = \frac{n_A}{n} = \frac{A所包含的样本点数}{样本点总数} 称有限等可能试验中事件A的概率P(A)为古典型概率。1.3.2 几何型概率当试验的样本空间是某区域，以L(\Omega)表示其几何度量。事件A的样本点所表示的区域为\Omega_A，则事件A的概率是的几何度量的几何度量 P(A) = \frac{L(\Omega_A)}{L(\Omega)} = \frac{\Omega_A的几何度量}{\Omega的几何度量} 称这种样本点个数无限但是几何度量上的等可能试验中事件A的概率P(A)为几何型概率1.3.3 n重伯努利试验把一个随机试验独立重复做若干次，即各次试验所联系的事件之间相互独立，且同一事件在各个试验中出现的概率相同，称为独立重复试验。如果每次试验只有两个结果和A和\overline{A}，则称这种试验为伯努利试验。将伯努利试验独立重复进行n次，称为n重伯努利试验。​ 设在每次试验中，概率P(A) = p(0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计算机输入输出系统接口实验报告]]></title>
      <url>%2F2017%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[实验一 环境熟悉与I/O地址译码一、实验目的​ 掌握I/O地址译码电路的工作原理。 二、实验内容 连接AD4~AD9等几根线，使得138译码器Y0#~Y7#译码出的地址依次分别是Y0#：200H~20FH; Y1#：210H~21FH；……；Y7#：270h~27FH 利用Source-&gt;Add/Remove Source files中添加源程序EX-138.ASM（在实验包中已提供），该程序向240H端口写任意数据。如果是第一次运行，Source Code Filename这一项选New来调入源程序。 在Source菜单下点击“Build All”，汇编源代码（全部编译）；执行程序，查看Y0~Y7中是否Y4#脚输出为有效（管脚出的有颜色的小方块为红色是高电平，蓝色为低电平）. 改变程序中的输出地址，使得Y0#, Y1#,Y6#,Y7#分别有效。 改变A9~A3的接线方法，从而得到Y0；388H~38FH；Y1：398H～39FH; ……；Y7：3F8H~3FFH。并修改上一问的程序，以同样使得Y4#有效。 1）源程序1234567891011121314.8086.MODEL SMALL.STACK.DATA ADDRESS WORD 3C8H; 此值会变.CODESTART: MOV AX,@DATA MOV DS,AX MOV DX,ADDRESS MOV AL,0 OUT DX,AL JMP $END START 2）电路原理图（138译码部分）1. 2. 3）运行结果贴图（138译码及上面两个273的输出） 实验二 可编程中断控制器8259一、实验目的1． 掌握8259的基本工作原理和编程方法。 2． 深入了解中断的概念和实地址模式下中断处理程序的编写方法。 二、实验内容​ 将接口实验包中所带的EX-8259.DSN文件用ISIS 7打开。按手册接线并执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.MODEL SMALL.8086.stack.datacome byte 00000000B ; 计算中断到来次数的变量.codestart: mov ax,@data mov ds,ax cli mov ax,0 ; init interrupt vector TABLE mov es,ax mov si,0 ; 由于模拟器的错误，所有中断向量需要指向同一个地址 mov cx,255l: mov ax,offset int0 mov es:[si],ax mov ax,seg int0 mov es:[si+2],ax add si,4 loop l mov ax,offset int0 mov es:[si],ax mov ax,seg int0 mov es:[si+2],ax mov ax,@data mov ds,ax mov al,00010011b ; init 8259 mov dx,210h out dx,al ; ICW1 mov al,60h mov dx,212h out dx,al ; ICW2 mov ax,00000001h out dx,al ; ICW4 mov ax,0 out dx,al ; OCW1 sti jmp $int0 proc push ax push dx push ds mov ax,@data mov ds,ax mov ax,0 mov al, come ; 中断到来，计数器+1 inc al mov come, al mov al,20h ; 发EOI命令 mov dx,210h out dx,al pop ds pop dx pop ax iretint0 endpEND start 三、运行结果贴图（执行三次中断，每次中断后的8086寄存器的截图） 实验三 可编程定时器计数器8253一、实验目的​ 掌握8253的基本工作原理、编程方法及其应用。 二、实验内容一） 研究定时计数器（选）1）源程序12345678910111213.8086.MODEL SMALL.STACK.DATA.CODESTART: MOV AL,00010001B; 使用计数器0，只写低八位，模式0，BCD码 MOV DX,226H OUT DX,AL MOV AL,10H MOV DX,220H OUT DX,ALEND START 2）讨论题​ 如果把方式0改成方式1，电路不动，则按下BUTTON后，计数器值会否减1？为什么？ 不会，因为模式一计数是从gate处于上升沿时开始，而这里gate连接电源，始终保持高电平，不会出现上升沿。 3）接线原理图和运行结果图 二）信号发生器1）源程序12345678910111213141516171819202122232425262728293031.8086.MODEL SMALL.STACK.DATA.CODESTART: MOV AL,00110111B; 使用计数器0，先写低八位，后写高八位，使用模式三，BCD码 MOV DX,226H OUT DX,AL MOV AX,1000H MOV DX,220H OUT DX,AL MOV AL,AH OUT DX,AL; 计数器初始值为1000 MOV AL,01110111B; 使用计数器1，先写低八位，后写高八位，使用模式三，BCD码 MOV DX,226H OUT DX,AL MOV AX,1000H MOV DX,222H OUT DX,AL MOV AL,AH OUT DX,AL; 计数器初始值为1000 MOV AL,10010111B; 使用计数器2，只使用低八位，使用模式三，BCD码 MOV DX,226H OUT DX,AL MOV AL,5H MOV DX,224H OUT DX,AL; 计数器初始值为5END START 2）接线原理图 3）运行结果图 4）编程与调试心得（遇到的问题和解决的办法，以及获得的收获）​ 对于OUT2口的波形如果不取反的话就会得到占空比为3:5的方波。 实验五 七段数码管实验一、实验目的​ 掌握数码管显示数字的原理，进一步复习8255的应用。 二、实验内容1.静态显示（选）1）源程序123456789101112131415161718192021222324252627.8086.MODEL SMALL.STACK.DATA ARR BYTE 3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,6FH,77H,7CH,39H,5EH,79H,71H.CODESTART: MOV AX,@DATA MOV DS,AX MOV AL,10000001B; A组模式0，A口和C口高四位为输出。B组模式0，B口为输出，C口低四位为输入。 MOV DX,206H OUT DX,AL MOV DX,204H IN AL,DX NOT AL MOV AH,0H MOV DL,16 DIV DL MOV AL,AH MOV AH,0H MOV BX,AX LEA DI,ARR MOV AL,[DI+BX] MOV DX,200H OUT DX,AL JMP $END START 2）接线原理图和运行结果图 2.动态展示1）源程序1234567891011121314151617181920212223242526272829303132333435363738394041424344.8086.MODEL SMALL.STACK.DATA ARR BYTE 3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,6FH,77H,7CH,39H,5EH,79H,71H.CODESTART: MOV AX,@DATA MOV DS,AX MOV AL,10001001B MOV DX,206H OUT DX,AL LEA DI,ARRLP: MOV DX,204H IN AL,DX NOT AL MOV AH,0 MOV DL,16 DIV DL MOV SI,AX MOV AL,01H MOV DX,202H OUT DX,AL MOV BX,SI MOV BH,0 MOV DX,200H MOV AL,[DI+BX] OUT DX,AL MOV CX,64H LOOP $ MOV AL,02H MOV DX,202H OUT DX,AL MOV BX,SI MOV BL,BH MOV BH,0 MOV DX,200H MOV AL,[DI+BX] OUT DX,AL MOV CX,64H LOOP $ JMP LPEND START 2）接线原理图和运行结果图 3）编程与调试心得（遇到的问题和解决的办法，以及获得的收获）​ 刚开始只有一个数字有显示，后来才想到通过PB0/1片选高位还是低位亮。其实是高位和低位交替亮。这个实验让我对8255的使用有了更深的体会。 实验六 交通灯控制实验一、实验目的​ 通过并行接口8255实现十字路口交通灯的模拟控制,进一步掌握对并行口的使用和中断的使用。 二、交通灯变化规律十字路口交通灯的变化规律要求 1） 南北路口的绿灯、东西路口的红灯同时亮10秒，然后 2） 南北路口的黄灯闪烁2次（闪烁周期2秒），同时东西路口的红灯继续亮，然后 3） 南北路口的红灯、东西路口的绿灯同时亮10秒，然后 4） 南北路口的红灯继续亮，同时东西路口的黄灯2次（闪烁周期2秒），然后 5） 转1重复。 三、实验内容​ 红黄绿三色交通灯控制。将接口实验包中所带的EX-825X-1.DSN文件用ISIS 7打开，将D6、D5、D4作为南北路口的交通灯与PA7、PA6、PA5相连；D3、D2、D1作为东西路口的交通灯与PA2、PA1、PA0相连(方式0)。利用8253产生1秒的中断信号(系统已经为CLK0提供了一个1MHz的时钟输入)，在中断处理程序中用程序处理10秒延迟和两次黄灯闪烁的问题。编程使六个灯按交通灯变化规律燃灭。 1）源程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 .8086.MODEL SMALL.STACK.DATA COUNT BYTE 0H.CODESTART: MOV AX,@DATA MOV DS,AX MOV DX,226H MOV AL,00110111B OUT DX,AL MOV AX,1000H MOV DX,220H OUT DX,AL MOV AL,AH OUT DX,AL ;C0 MOV DX,226H MOV AL,01110111B OUT DX,AL MOV AX,1000H MOV DX,222H OUT DX,AL MOV AL,AH OUT DX,AL ;C1 MOV AL,10000000B MOV DX,206H OUT DX,AL MOV AL,10000001B MOV DX,200H OUT DX,AL CLI MOV AX,0 MOV ES,AX MOV SI,0 MOV CX,255L: MOV AX,OFFSET INT0 MOV ES:[SI],AX MOV AX, SEG INT0 MOV ES:[SI+2],AX ADD SI,4 LOOP L MOV AX,OFFSET INT0 MOV ES:[SI],AX MOV AX,SEG INT0 MOV ES:[SI+2],AX MOV AX,@DATA MOV DS,AX STI MOV AL,00010011B ; INIT 8259 MOV DX,210H OUT DX,AL ; ICW1 MOV AL,00001000B MOV DX,212H OUT DX,AL MOV AL,01H OUT DX,AL JMP $ INT0 PROC PUSH SI PUSH AX PUSH DX PUSH DS MOV AX,@DATA MOV DS,AX MOV AL,COUNT INC AL MOV COUNT,AL CMP AL,10 JZ DO1 CMP AL,11 JZ DO2 CMP AL,12 JZ DO1 CMP AL,13 JZ DO2 CMP AL,14 JZ DO3 CMP AL,24 JZ DO4 CMP AL,25 JZ DO5 CMP AL,26 JZ DO4 CMP AL,27 JZ DO5 CMP AL,28 JZ DO6 JMP EXITDO6: MOV AL,10000001B ;左绿右红 MOV DX,200H OUT DX,AL MOV AL,0 MOV COUNT,AL JMP EXITDO1: MOV AL,01000001B ;左黄灯亮 MOV DX,200H OUT DX,AL JMP EXITDO2: MOV AL,00000001B ;左黄灯暗 MOV DX,200H OUT DX,AL JMP EXITDO3: MOV AL,00100100B ;左红右绿 MOV DX,200H OUT DX,AL JMP EXITDO4: MOV AL,00100010B;右黄灯亮 MOV DX,200H OUT DX,AL JMP EXITDO5: MOV AL,00100000B ;右黄灯暗 MOV DX,200H OUT DX,AL JMP EXITEXIT: MOV AL,20H MOV DX,210H OUT DX,AL POP DS POP DX POP AX POP SI IRET INT0 ENDPEND START 2）接线原理图 3）运行结果截图 4）编程与调试心得（遇到的问题和解决的办法，以及获得的收获）​ 循环很多，一不小心就会写错。如何让黄灯闪烁也想了很久。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计算机输入输出系统汇编实验报告]]></title>
      <url>%2F2017%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[实验一 汇编语言程序上机过程一）实验目的 学会安装“16位汇编程序开发软件”的安装，完成将汇编语言源程序录入进计算机、利用ml.exe进行汇编，LINK进行链接，并用DEBUG调试16位程序的全部过程。本实验大家不必了解程序细节，只是为了熟悉开发环境和上机过程。 二）实验内容 写16位汇编程序，从键盘输入一个字符串，然后换行后将该字符串输出到屏幕。 源程序 1234567891011121314151617181920212223242526272829.8086.MODEL SMALL.DATAORG 100H;CS起始地址STR DB 20,0,20 DUP(20H);字符串STR.CODESTART: MOV AX,@DATA MOV DS,AX;数据段地址 LEA DX,STR;将STR的相对于数据段首地址的偏移地址放进DX MOV AH,0AH INT 21H;从键盘输入一个字符串 MOV DL,0AH MOV AH,02 INT 21H;输出DL中的换行 MOV DL,0DH MOV AH,02 INT 21H;输出回车 MOV BL,STR[1] MOV BH,0;BX=20 MOV BYTE PTR STR[BX+2],&apos;$&apos;;末尾加&apos;$&apos; LEA DX,STR+2 MOV AH,9 INT 21H;输出这一句话 MOV AH,4CH INT 21H;返回DOSEND START 运行结果贴图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） INT 21的9号调用输出以DS:DX为首地址，”\$”为结尾的字符串到显示器中。若要在显示字符串光标自动回车换行，则在”$”字符前面加上0DH(回车),0AH(换行)字符。 实验二 顺序程序设计一）实验目的 通过这一部分的实验，进一步熟悉汇编过程和DEBUG调试过程；掌握用汇编语言编写顺序程序。 二）实验内容 写完整程序16位程序，在内存中从Table开始的10个单元中连续存放0到9的平方值，任给一个0到9的数X，该数存放在内存单元XX中，用XLAT指令查表求X的平方值，并将结果存于内存YY单元中。编写程序，并在DEBUG中进行调试和验证结果。(X，XX，YY都是内存中的变量） 源程序 12345678910111213141516.8086.MODEL SMALL.STACK.DATA Table BYTE 0,1,4,9,16,25,36,49,64,81 XX BYTE 9 YY BYTE ?.CODESTART: MOV AX,@DATA MOV DS,AX LEA BX,Table MOV AL,XX XLAT;以DS:[BX+AL]为地址，提取存储器中的一个字节再送入AL。 MOV YY,ALEND START 运行结果贴图 可以看到DS:000A放的是09H，查找后AL中放的是51H=81D，存入YY=DS:000B中。 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） XLAT的指令功能：把待查表格的一个字节内容送到AL累加器中。在执行该指令前，应将Table先送至BX寄存器中，然后将待查字节与其在表格中距表首地址位移量送AL,即AL&lt;–((BX)+(AL)). 执行XLAT将使待查内容送到累加器。 实验三 分支程序设计一）实验目的 通过本实验，熟练运算类指令对标志位状态的影响，以及标志位状态的表示方法；掌握无条件转移、条件转移指令的使用方法；掌握分支程序设计和调试方法。 二）实验内容 所谓回文字符串是指一个字符串正读和倒读都是一样的，例如字符串‘ABCDEFFEDCBA’就是一个回文字符串，而字符串‘ABCFDDCAB’就不是回文字符串。现在编写完整的16位汇编程序，输入一个字符串，判断该字符串是否为回文字符串，并用“It is a palindrome”或“It is NOT a palindrome”作为输出。 源程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.8086.MODEL SMALL.STACK.DATA N EQU 20 MAXLEN BYTE N ACTLEN BYTE ? STRING BYTE N DUP(&apos;$&apos;) TRUE BYTE 0AH,0DH,&apos;It is a palindrome&apos;,0AH,0DH,&apos;$&apos; ;开头加0AH、0DH是为了防止回车把输入冲掉 FALSE BYTE 0AH,0DH,&apos;It is NOT a palindrome&apos;,0AH,0DH,&apos;$&apos;.CODESTART: MOV AX,@DATA MOV DS,AX MOV AH,0AH MOV DX,OFFSET MAXLEN INT 21H;缓冲区的第一个字节指定容纳的最大字符个数，由用户给出；第二个字节存放实际的最大字符个数，由系统最后填入；从第三个字节开始存放从键盘接受的字符，直到ENTER键结束。 MOV AL,ACTLEN MOV AH,0 MOV BL,2 DIV BL CMP AH,1 JE ITSODD;如果是奇数字数的字符串，跳到&quot;It&apos;s odd&quot; CMP AL,1 JE ITSTWO;如果是两个字符的字符串，跳到&quot;It&apos;s two&quot; ADD AL,AH;奇数个数和偶数个数的区别就在这句话 MOV AH,0 MOV BL,ACTLEN MOV BH,0 MOV SI,BX MOV BX,OFFSET STRING DEC SIITSEVEN: CMP SI,AX JNA T MOV DL,[BX+SI] MOV DH,[BX] CMP DL,DH JNZ F INC BX SUB SI,2;因为BX加了一，所以BX+SI要想减一，就需要SI减二 JMP ITSEVENITSODD: MOV AH,0 MOV BL,ACTLEN MOV BH,0 MOV SI,BX MOV BX,OFFSET STRING DEC SIJUDGEODD: CMP SI,AX JNA T MOV DL,[BX+SI] MOV DH,[BX] CMP DL,DH JNZ F INC BX SUB SI,2 JMP JUDGEODDITSTWO: MOV BX,OFFSET STRING MOV DL,[BX+1] MOV DH,[BX] CMP DL,DH JNE F;如果这两个字符不相同，就不是。否则直接向下执行TT: MOV DX,OFFSET TRUE JMP QUITF: MOV DX,OFFSET FALSE JMP QUITQUIT: MOV AH,09H INT 21H MOV AH,4CH INT 21HEND START 运行结果贴图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） TRUE和FALSE字符串开头加0AH、0DH可以防止回车把输入冲掉 奇偶情况不同，并且两个字符的情况与其他的偶数情况不同 实验四 循环程序设计一）实验目的 通过实验，可以掌握循环结构的各种实现方法，进一步了解循环结构中初始化部分、循环体部分、循环控制部分的功能以及他们彼此之间的关系。尤其是多重循环中外层循环和内层循环之间的关系。 二）实验内容 请编写16位完整汇编程序，在一个升序字节数组BUFF中查找数N，找到后将此数从数组中删除，并使得CF=0；没找到返回CF＝1。 源程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.8086.MODEL SMALL.STACK.DATA BUFF BYTE 0,1,2,3,4,5,6,7,8,9.CODESTART: MOV AX,@DATA MOV DS,AX MOV CX,10;计数初始化为10 LEA SI,BUFF;BUFF首地址给SI MOV AH,01H INT 21H;从键盘输入一个字符 SUB AL,30H;将ASCII码变成数字 MOV AH,0NEXT: MOV BL,[SI] MOV BH,0 CMP AX,BX JE DEL;找到了就跳至删除 INC SI LOOP NEXT JMP STOP;找不到就停DEL: MOV DI,SI;记住当前元素的位置 INC SI MOV AL,[SI] MOV AH,0 MOV [DI],AX;后面的内容前移 LOOP DEL MOV [SI],0;找到的最后一位换成0 LEA SI,BUFF;SI指向BUFF首地址 MOV CX,9;设计数器为9 MOV AH,02H MOV DL,0DH INT 21H;回车 MOV DL,0AH INT 21H;换行DO: MOV DL,[SI] MOV DH,0 ADD DX,3030H;十六进制转ASCII INC SI INT 21H;一个个输出此时BUFF内容 LOOP DOSTOP: MOV AH,4CH INT 21H;退回DOSEND START 运行结果截图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） 八位寄存器中的两位十六进制数可以加减30H变成想要的ASCII码或者数字，十六位寄存器中的四位十六进制数可以加减3030H变成想要的ASCII码或者数字。 实验五 子程序设计一）实验目的 通过本实验，掌握子程序的定义和调用方法。通过程序调试，进一步理解CALL指令和RET指令的功能，掌握子程序调用时参数传递的方法。 二）实验内容 请编写完整16位汇编程序从键盘读取字符，如果是十进制的‘0’～‘9’则在屏幕上输出该数的8位二进制码，并将数字依次存放到BUF开头的数组中，如果读入的字符是’Q’或者‘q’，则程序退出，其他情况在屏幕上打印“You must input 0~9, or ‘q’ or ‘Q’”。（如输入的字符是‘9’，则输出“00001001”）.提示：输出一个数的2进制形式应该从最高位开始输出。要求打印一个数的2进制形式和输出回车换行分别定义成一个子程序可以将此段程序定义成一个过程。 源程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.8086.MODEL SMALL.STACK.DATA STRING DB &apos;You must input 0~9, OR `Q` OR `q`&apos;,0AH,0DH,&apos;$&apos; BUF DB 8 DUP(30H),&apos;$&apos;.CODESTART: MOV AX,@DATA MOV DS,AX MOV AH,01H INT 21H CMP AL,&apos;q&apos; JE EXIT CMP AL,&apos;Q&apos; JE EXIT;输入&apos;q&apos;或&apos;Q&apos;时退出 CMP AL,&apos;0&apos; JL WRONG CMP AL,&apos;9&apos; JG WRONG;输入小于零或者大于九时错误 MOV BL,AL MOV AH,02H MOV DL,0DH INT 21H MOV DL,0AH INT 21H;回车换行 MOV AL,BL SUB AL,30H;ASCII码转数字 MOV DX,0 MOV AH,0 MOV BX,OFFSET BUF+7AGAIN: MOV DX,0;余数清零 MOV CX,2 DIV CX ADD DL,30H;转ASCII码 MOV [BX],DL;将零或一附给BX所指内存中的元素 DEC BX;向左移一位 AND AX,AX JNE AGAIN;AX不为零就继续循环 JMP RIGHT;其实这句可有可无，当时随便就写上了RIGHT: MOV AH,09H LEA DX,BUF INT 21H;输出BUF内容 JMP EXITWRONG: MOV AH,09H LEA DX,STRING INT 21H;输出STRING内容 JMP EXITEXIT: MOV AH,4CH INT 21H;退出到DOSEND START 运行结果截图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） 刚开始没想取余数从十六进制转到二进制，后来发现我也不知道什么太好的办法-_-||| 通过写这个程序，我对DIV有了更深的认识。 Programming a sub routine to calculate N!. Specific requirements：Read a number N(1~6) from keyboard，programming a sub routine named DAC to calcute N！, then print the result to screen in decimal form. 源程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.8086.MODEL SMALL.STACK.DATA STRING BYTE 6 DUP(20H),&apos;$&apos; ENDL BYTE 0AH,0DH,&apos;$&apos; ERRMSG BYTE &apos;You must input a number from 1~6&apos;,0AH,0DH,&apos;$&apos;.CODESTART: MAIN PROC MOV AX,@DATA MOV DS,AX MOV AH,01H INT 21H CMP AL,&apos;1&apos; JL ERR;小于1的ASCII码错误 CMP AL,&apos;6&apos; JG ERR;大于6的ASCII码错误 SUB AL,30H MOV CL,AL LEA DX,ENDL MOV AH,09H INT 21H MOV DX,0 LEA BX,STRING+5 MOV AL,01H MOV AH,0 MOV CH,0 CALL DAC CALL PRINT MAIN ENDP DAC PROCAGAIN: MOV DX,CX MUL DX LOOP AGAIN DAC ENDP PRINT PROC MOV CX,10DO: MOV DX,0 DIV CX ADD DL,30H DEC BX MOV [BX],DL AND AX,AX JNE DO MOV DX,BX MOV AH,09H INT 21H MOV AH,4CH INT 21H PRINT ENDP ERR: LEA DX,ENDL MOV AH,09H INT 21H LEA DX,ERRMSG MOV AH,09H INT 21H MOV AH,4CH INT 21HEND START 运行结果截图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） 通过写这个程序，我对子程序设计更加熟悉。 在附加段中有一个从小到大排序的无符号数字数组，其首地址在DI中，数组的第一个单元存放数组长度。要求用折半查找法在数组中查找数N，假设该数已在AX中，如找到，CF=0，并在SI中给出该元素在数组中的偏移地址；如未找到，CF=1。 源程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.8086.MODEL SMALLEXTRA SEGMENT ARRAY BYTE 10,1,2,3,4,5,6,7,8,9,10EXTRA ENDS.CODEASSUME ES:EXTRASTART: MOV BX,EXTRA MOV ES,BX LEA DI,ES:ARRAY MOV AL,7 MOV CX,0 MOV CL,ES:[DI] INC DI MOV DX,DI ADD DX,CX MOV SI,DX MOV DX,0 CMP AL,ES:[DI] MOV BX,DI JB NOTFOUND JE FOUND CMP AL,ES:[SI-1] MOV BX,SI JA NOTFOUND JE FOUNDWORK: MOV BX,DI ADD BX,SI SHR BX,1 CMP AL,ES:[BX] JZ FOUND PUSHF CMP BX,DI JZ NOTFOUND POPF JL LESS MOV DI,BX JMP WORKLESS: MOV SI,BX JMP WORKNOTFOUND: STC JMP EXITFOUND: CLC MOV BX,SI JMP EXITEXIT: MOV AH,4CH INT 21HEND START 运行结果截图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） 我对二分查找的本质有了更深刻的理解，了解了ES的声明方式。 在内存中有一个数组，里面是放着10个学生的某科的成绩，分别是：85,73,92,66,91,98,52,87,83,68， 请用冒泡排序法将这10个数从大到小排序，并将排序的结果在屏幕上打印出来，要求一个数一行的格式输出。 源程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.8086.MODEL SMALL.STACK.DATA SCORE DB 85,73,92,66,91,98,52,87,83,68 ENDL DB 0AH,0DH,&apos;$&apos;.CODESTART: MOV AX,@DATA MOV DS,AX MOV DI,OFFSET SCORE MOV AX,0 MOV BX,0 MOV CX,09H MOV DX,0C1: MOV DX,CX MOV DI,OFFSET SCOREC2: MOV AL,[DI] MOV BL,[DI+1] CMP AL,BL JB CHANGE JMP NEXTCHANGE: MOV [DI],BL MOV [DI+1],ALNEXT: INC DI LOOP C2 MOV CX,DX LOOP C1 MOV CX,10 MOV DI,OFFSET SCOREPRINT: MOV AH,0 MOV AL,[DI] MOV BL,10 DIV BL MOV DX,AX ADD DX,3030H MOV AH,02H INT 21H MOV DL,DH INT 21H MOV DX,OFFSET ENDL MOV AH,09H INT 21H INC DI LOOP PRINT MOV AH,4CH INT 21HEND START 运行结果贴图 编程与调试心得（遇到的问题和解决的办法，以及获得的收获） 要注意在排序的过程中对CX值的保存。以及数组元素大小比较。 但是很奇怪的是在我的==WindowsXP上的CMD中无法正确执行，但是在DOSBOX中可以执行==，所以。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统实验二]]></title>
      <url>%2F2017%2F05%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[操作系统实验二生产者——消费者问题71115115 王子卓 2017年5月6日一.实验目的 通过实验,掌握 Windows 和 Linux 环境下互斥锁和信号量的实现方法,加深对临界区问题和进程同步机制的理解,同时熟悉利用 Windows API 和 Pthread API 进行多线程编程的方法。 二.实验内容 在 Windows 操作系统上,利用 Win32 API 提供的信号量机制,编写应用程序实现生产者——消费者问题。 在 Linux 操作系统上,利用 Pthread API 提供的信号量机制,编写应用程序实现生产者——消费者问题。 两种环境下,生产者和消费者均作为独立线程,并通过 empty、 full、 mutex三个信号量实现对缓冲进行插入与删除。 通过打印缓冲区中的内容至屏幕,来验证应用程序的正确性。 具体内容可参见“Operating System Concepts (Seventh Edition)” Chapter 6后的 Project(P236-241)。 三.实验环境 Windows XP + Ubuntu 16.04 LTS 四.实验步骤1.Linux 编写程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;semaphore.h&gt;#define BUFFER_SIZE 10char *buffer;sem_t mutex,empty,full;int producer_count,consumer_count;void output()&#123; for(int i=0;i&lt;BUFFER_SIZE;i++)&#123; printf("%c ",buffer[i]); &#125; printf("\n");&#125;void *producer(void *ptr)&#123; int count=0; do&#123; sem_wait(&amp;empty); sem_wait(&amp;mutex); printf("生产者线程编号:%lu%s%d%s\t",pthread_self(),"\t计数:",producer_count%BUFFER_SIZE,"\t\t\t"); buffer[(producer_count++)%BUFFER_SIZE]='1'; output(); count++; sem_post(&amp;mutex); sem_post(&amp;full); &#125;while(count!=5);&#125;void *consumer(void *ptr)&#123; int count=0; do&#123; sem_wait(&amp;full); sem_wait(&amp;mutex); printf("消费者线程编号:%lu%s%d%s\t",pthread_self(),"\t计数:",consumer_count%BUFFER_SIZE,"\t\t\t"); buffer[(consumer_count++)%BUFFER_SIZE]='0'; output(); count++; sem_post(&amp;mutex); sem_post(&amp;empty); &#125;while(count!=5);&#125;int main(int argc, char *argv[])&#123; producer_count=0; consumer_count=0; buffer = (char*) malloc(BUFFER_SIZE*sizeof(char*)); for(int i=0;i&lt;BUFFER_SIZE;i++)&#123; buffer[i]='0'; &#125; sem_init(&amp;mutex,1,1); sem_init(&amp;empty,0,BUFFER_SIZE); sem_init(&amp;full,0,0); pthread_t tid[10]; pthread_attr_t attr; pthread_attr_init(&amp;attr); for(int i=0;i&lt;5;i++)&#123; pthread_create(&amp;tid[i],&amp;attr,consumer,NULL); pthread_create(&amp;tid[i+5],&amp;attr,producer,NULL); &#125; for(int j=0;j&lt;10;j++)&#123; pthread_join(tid[j],NULL); &#125; return 0;&#125; 编译配置： 由于我用Qt Creator编写程序，所以需要在.pro文件中加入特定参数： 1234567TEMPLATE = appCONFIG += consoleCONFIG -= app_bundleCONFIG -= qtSOURCES += main.cLIBS += -lpthread 2.Windows 编写程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;using namespace std;typedef int buffer_item;#define BUFFER_SIZE 5buffer_item buffer[BUFFER_SIZE];HANDLE mutex,empty,full;int producer_count=0,consumer_count=0;void output()&#123; for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;buffer[i]&lt;&lt;"\t"; &#125; cout&lt;&lt;endl;&#125;int insert_item(buffer_item item)&#123; int state=0; WaitForSingleObject(empty,INFINITE); WaitForSingleObject(mutex,INFINITE); printf("现在producer_count是%d,正在生产\n",producer_count); if(buffer[producer_count]!=-1)&#123; state = -1; &#125;else&#123; buffer[producer_count] = item; producer_count = (producer_count++)%BUFFER_SIZE; &#125; Sleep(500); output(); ReleaseMutex(mutex); ReleaseSemaphore(full,1,NULL); printf("生产释放\n"); return state;&#125;int remove_item(buffer_item *item)&#123; int state = 0; WaitForSingleObject(full,INFINITE); WaitForSingleObject(mutex,INFINITE); printf("现在consumer_count是%d,正在消费\n",consumer_count); if(buffer[consumer_count]!=-1)&#123; *item = buffer[consumer_count]; buffer[consumer_count] = -1; consumer_count = (consumer_count++)%BUFFER_SIZE; &#125;else&#123; state = -1; &#125; Sleep(500); output(); ReleaseMutex(mutex); ReleaseSemaphore(empty,1,NULL); printf("消费释放\n"); return state;&#125;DWORD WINAPI producer(void *ptr)&#123; buffer_item randb; srand((unsigned)time(NULL)); while(true)&#123; randb = rand(); printf("现在生产者准备生产%d\n",randb); if(insert_item(randb))&#123; printf("生产者出了问题\n"); &#125;else&#123; printf("生产者生产了%d\n\n",randb); &#125; &#125;&#125;DWORD WINAPI consumer(void *ptr)&#123; buffer_item item; srand((unsigned)time(NULL)); while(true)&#123; printf("现在消费者准备消费\n"); if(remove_item(&amp;item))&#123; printf("消费者出了问题\n"); &#125;else&#123; printf("消费者消费了%d\n\n",item); &#125; &#125;&#125;int main()&#123; mutex = CreateMutex(NULL,false,NULL); empty = CreateSemaphore(NULL,5,5,NULL); full = CreateSemaphore(NULL,0,5,NULL); for(int i=0;i&lt;BUFFER_SIZE;i++)&#123; buffer[i]=-1; &#125; DWORD ConsumerTid,ProducerTid; HANDLE ConsumerTH,ProducerTH; int Param = 10; ConsumerTH = CreateThread(NULL,0,&amp;consumer,&amp;Param,0,&amp;ConsumerTid); ProducerTH = CreateThread(NULL,0,&amp;producer,&amp;Param,0,&amp;ProducerTid); Sleep(5000); TerminateThread(ConsumerTH,0); TerminateThread(ProducerTH,0); CloseHandle(ConsumerTH); CloseHandle(ProducerTH); system("pause"); return 0;&#125; 五.主要数据结构及其说明 定义BUFFER_SIZE：#define BUFFER_SIZE 10 定义互斥信号量mutex，用于保证生产者生产的时候消费者不能消费，消费者消费的时候生产者不能生产。 定义信号量empty，代表缓冲区中空格子的个数。 定义信号量full，代表缓冲区中满格子的个数。 定义整型变量producer_count，用来表示生产者在缓冲区中的游标位置。 定义整型变量consumer_count，用来表示消费者在缓冲区中的游标位置。 六.程序运行结果 Linux运行结果： Windows运行结果： 七.实验体会 在Linux系统中pthread库不是默认的库，连接时需要使用静态库 libpthread.a，在编译中要加 -pthread参数。比如： 1gcc -pthread ./main.c 然而我使用了Qt Creator编写程序，直接在.pro文件中加入LIBS += -lpthread即可。 在具体实现时，需要注意信号量的顺序，比如生产者线程中： 12sem_wait(&amp;empty);sem_wait(&amp;mutex); 如果顺序相反，将会导致死锁。生产者经过sem_wait(&amp;mutex)之后，如果信号量empty的值等于零，也就是说缓冲区中没有空格子，将无法继续生产，然而此时消费者也没有办法消费，从而死锁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件体系结构复习]]></title>
      <url>%2F2017%2F04%2F10%2F%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[软件系统设计与体系结构一.基于软件重用的设计方法学1.软件重用(1)定义 软件重用是一种由预先构造好的、以重用为目的而设计的软件构件来建立或组装软件系统的过程。 (2)重用方法 代码复用 设计复用 分析复用 测试信息复用 (3)优缺点 优点:在已有工作的基础上，充分利用以前系统开发中积累的知识和经验 ，将开发的重点转移到现有系统的特有构成成分。 缺点: 过程方面：缺少支持软件重用的软件开发过程 工程方面：缺乏支持实施软件重用的工具、没有构件重用库或库信息很快过时 组织方面：管理者轻视 资金方面：初期投入大 (4)原则 在已有工作的基础上，充分利用以前系统开发中积累的知识和经验 ，将开发的重点转移到现有系统的特有构成成分。 (5)判断题 启动软件重用仅仅是为了引入合适的技术(X) 软件重用可能会有用，但太昂贵(√) 采用OO的程序设计语言会导致系统化的重用(X) 只能将重用局限在代码构件上(X) 开发人员要从数以万计的小构件中选取要重用的构件(X) 只要建立可重用构件库就会促使构件重用(X) 启动软件重用仅仅是为了引入合适的技术(X) 2.构件技术(1)定义 语义完整、语法正确和有重用价值的软件单元，是软件重用过程中可明确辨识的成分。 (2)获取途径 从现有构件中获得（★提倡） 通过遗留工程 现成的商业构件 开发新构件 (3)好处 ​ (4)人员划分 通过实现构件库管理系统，软件开发人员被分为两类：构件开发人员和构件组装人员，实现了软件开发人员的合理分工。 二.软件体系架构SA的概念1.发展历程(1)发展历程 “无体系结构”设计阶段：汇编语言，规模小，无需建模 萌芽阶段——程序结构设计阶段：高级程序语言，SA的概念被明确 初级阶段——模块结构阶段：OO技术，从多角度对系统建模（如UML） 高级阶段——构件结构阶段：以Kruchten提出的“4+1”模型为标志 尽管目前仍存在许多问题，但地位已经迅速上升。 (2)重用粒度的提升 重用粒度提升的原因： 软件系统规模和复杂度的提升 软件行业开发经验的积累及相关理论的提出 (3)SA的定义 尽管目前有很多对SA的定义，但我们倾向于更容易被理解的Garlan &amp; Shaw 模型 SA={Component, Connectors, Constrains} 软件体系架构=构件+连接件+约束（配置） 2.SA的构成要素(1)软件构件 强调三点： 构件的粒度 构件内部 端口 补充一点： 还要关注构件的进化能力，它是系统进化的基础。 (2)连接件 用来建立构件间的交互，以及支配这些交互规则的体系结构的构造模块。 常见的连接件： | 体系结构 | 连接件名称 || :——-: | :——-: || “客户机/服务器” | 通信协议或通信机制 || “管道-过滤器” | 管道（Pipe） | (3)约束(配置) 描述了体系结构的构件与连接件的连接图，它一般是对象连接时的规则，或指明构件连接的势态或条件。 三.SA风格1.SA定义 一般意义上，SA模式=SA风格，没有本质区别，因此可以从理解SA模式来理解SA风格。 模式——抽取重复问题，描述解决方案的核心。 SA模式：意图+上下文+问题+解决方案 两者也有少许区别： SA风格描述系统总体框架，而SA模式描述得更广 SA风格相对独立，而模式彼此依赖性较强 SA风格侧重抽取总体结构，模式更面向问题 2.经典风格的优缺点、应用场景(1)管道-过滤器 过滤器——过滤器接收数据输入，进行转化后输出。 管道——负责连接各个过滤器，负责它们之间的交互。 有三种常见变种: 流水线模式——批处理、Unix shell、编译器; 有界管道——限制数据量(带宽); 类型管道——限制数据类型通过。 优点： 软构件具有隐蔽性、高内聚、低耦合★ 支持并行执行★ 易于理解——系统行为=多个过滤器的行为 支持软件重用 易维护、增强系统性能简单(体现在增删中) 易于分析吞吐量、死锁等属性 缺点： 系统性能下降，且增加编写过滤器的复杂性★ 导致进程成为批处理的结构 不适合处理交互的应用 (2)数据抽象和面向对象风格 这种风格建立在数据抽象和面向对象的基础上。 优点： 易分解——可将数据存取操作分解为一些交互的代理程序的集合 ★ 易维护——改变一个对象内部的表示，不会影响其他对象(封装) 缺点： 过程调用依赖于对象标识的确定★ 不同对象的操作关联性弱，尤其是发生在多个对象同时访问一个对象时。 (3)基于事件的隐式调用风格 构件不直接调用一个过程，而是触发或广播一个或多个事件。 一个事件的触发=&gt;另一个模块中所有过程的调用 构成要素： 构件——是一些模块，既可以是一些过程，又可以是一些事件的集合。 连接件——触发信息、广播信息 约束——触发模块与过程执行模块间的联系规则 优点： 为软件重用提供了强大的支持★ 为改进带来了方便。 缺点： 构件放弃了对系统计算的控制★ 数据交换成问题(对于利用共享数据进行交互不利) 很难对系统的正确性进行推理(需要人的参与) 应用领域： 编辑器中支持语法检查——触发报警★ 数据库系统中用于检查一致性约束条件等 (4)层次系统风格 每一层为它的上层提供服务，并作为下层的客户，不能跨层调用。 由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。 优点： 支持基于抽象程度递增的系统设计★ 支持重用★ 支持功能增强，改实现不改接口 缺点： 一些系统不易被分层★ 很难找到一个合适的、正确的层次抽象方法 应用领域： 分层通信协议(OSI-ISO) OS 数据库系统 TCP/IP协议栈 (5)仓库风格和黑板风格 两种构件组成： 一个中央数据结构——当前状态 一批独立构件的集合——与中央数据结构交互 两类控制策略： 传统数据库(12306) 黑板体系结构(BBS) 优点： 便于多客户共享大量数据★ 添加知识源和扩展黑板数据结构都很方便 缺点： 要保证数据结构的完整和一致——系统复杂度增加(同步/加锁)★ 不同知识源代理对共享数据结构要一致——修改难(通过安装控件保持更新) (6)模型-视图-控制器风格MVC MVC风格将交互式应用划分为3种构件： 模型(Model) 视图(View) 控制器(Controller) 最重要的一点：用户只操作控制器构件，看视图构件的显示，不去碰模型构件里面的应用程序核心代码。 优点： 改变界面影响小，易于演化，可维护性好★ 分而治之，简化设计，保证了可扩展性 易于改变，动态机制良好 缺点： 仅局限在应用软件的用户界面开发领域中★ 应用领域： Windows应用程序的文档视图结构 Java Swing应用程序等 (7)解释器风格 创建了一个软件虚拟出来的机器。该系统的4个构件： 1个状态机——执行引擎 3个存储器 正在被解释的程序 被解释的程序的当前状态 执行引擎的当前状态 优点： 对未实现的硬件进行仿真★ 提升程序设计语言的跨平台能力 有助于应用程序的可移植性 缺点： 额外的间接层次带来了系统性能的下降★ 应用领域： 虚拟机★ 程序设计语言的编译器 基于规则的系统 脚本语言 题目 “构件不直接调用一个过程，而是触发或广播一个或多个事件”是那种SA风格？ 基于事件的隐式调用风格 采用OO的程序设计语言会导致系统化的重用(X系统化) 不应该将重用只局限在代码构件上(√) 比较 数据流风格 共享数据 抽象数据类型 隐式调用 管道-过滤器 算法变更 – - + + 数据表示变更 – ++ - – 功能变更 + - ++ + 性能 ++ -（*） – – 重用 – ++ - + 3.B/S 架构、C/S两层、三层架构(1)B/S风格 WWW浏览器技术——客户端 应用程序以网页形式存放于Web服务器上 用户通过键入URL，调用应用程序，对数据库进行操作 优点： 浏览器与Web服务器真正的连接时间很短，因此Web服务器可以为更多的用户提供服务。 缺点： 数据的动态交互性不强（尤其是一些需要及时响应的，经常交互的）——会“卡”,怎么办？————混合SA，即二层C/S+B/S (2)二层C/S风格 C/S体系结构的三个主要组成部分： 数据库服务器 客户应用程序 网络 服务器、客户应用程序的主要任务： 服务器——DB的安全性、控制并发、全局数据完整性规则、备份与恢复 客户应用程序——提供交互界面、提交用户请求并接收反馈、处理存在于客户端的数据 网络通信软件——完成数据库服务器和客户应用程序之间的数据传输 优点： 灵活 可扩展 通过合理地分解任务，可以使应用成本降低 缺点： 开发成本较高 客户端程序设计复杂 软件维护很麻烦 (3)三层C/S风格①二层C/S风格的局限性 二层C/S结构以单一服务器、局域网为核心的，难以扩展至大型企业广域网和Internet 软硬件结合以及集成能力有限 服务器负荷太重，性能低 数据安全性差，因为客户端程序可以访问数据库服务器，所以其他程序也可以使用类似的方法访问。 ②三层C/S风格的三个层次 表示层：应用的用户接口，担负着用户与应用间对话的功能。 功能层：应用的本体，是程序中具体的业务处理逻辑。 数据层：DBMS数据库管理系统，负责对数据库的读写。 ③优点 提高系统和软件的可维护性和可扩展性 可灵活选用相应的平台和硬件系统 高效地进行开发，且便于维护 为严格的安全管理奠定了坚实的基础 基本上符合软件设计关注的四大质量属性：可修改性、性能、安全性、可用性 4.异构结构风格(1)使用异构风格的原因 不同的结构都同时具有优缺点 关于软件包、框架、通信的标准的变动 遗留工程与遗留代码的使用 解释或表示习惯上的不同 (2)典型的异构体系结构——C/S与B/S的混合SA 企业内部C/S结构+企业外部B/S结构(“内外有别”) 修改数据C/S结构+查询数据B/S结构(“改查有别”) 都是对安全性和动态交互性能的权衡 四.SA描述1.SA描述方法及典型描述语言 SA风格是对经典应用系统的特征抽象,SA描述是对真正软件系统的具体展现 目前通用的描述SA的方法——非形式化的图和文本 缺点： 不能描述系统构件之间的接口 难于进行形式化分析和模拟 缺乏相应的支持工具帮助设计师完成设计工作 不能分析其一致性和完整性等特性 (1)SA的描述方法 SA的描述方法——软件体系结构描述语言（Architecture Description Language，ADL） SA的三个最基本的构成元素=&gt;ADL的三个基本构成要素 构件：基本计算单元、数据存储单元 连接件：用来建立构件间的交互，以及支配这些交互规则的体系结构构造模块 体系结构配置：描述1和2的连接图，提供信息来确定构件是否正确连接、接口是否匹配、连接件构成的通信是否正确，并说明实现要求行为的组合语义——澄清系统结构 ★好的ADL能够起到承上启下的作用 需求分析=&gt;SA设计（ADL）=&gt;软件设计 SA设计——桥梁 SA描述——效果图（建模） ADL——画效果图的工具（建模工具） 一个好的ADL——可以让SA描述方便地转换为其它设计文档，同时可利用需求分析成果直接生成系统的体系结构说明。 (2)典型SA描述语言 主要的SA描述语言 UniCon——支持异构的构件和连接件类型，并提供了关于体系结构的高层编译器 C2——支持构件重置与GUI重用 Wright——连接件=协议，协议刻画构件行为专注于抽象行为的精确表达，以及为架构师提供结构化表达系统信息的方法 ACME——是一种交互式ADL，它旨在为开发工具与环境提供交互格式。 总之，这些ADL都强调了体系结构的不同侧面，大部分ADL都是与领域相关，不利于对不同领域的体系结构进行分析。多种ADL并存的局面正在演化为几种通用的ADL。 2. 4+1模型(1)组成 (2)作用①4+1模型 使得有不同需求的人员能够得到他们想要了解的SA的某一方面。 ②逻辑视图 当采用面向对象的设计方法时，逻辑试图即是对象模型。 ③过程视图 描述系统的并发和同步方面的设计。 ④物理视图 描述软件与硬件之间的映射关系，反映系统在分布方面的设计。 ⑤开发视图 描述软件在开发环境下的静态组织结构。 ⑥场景视图 场景是用例的集合，这些用例对SA加以说明。 (3)关注点 逻辑视图 SA的组成以实现功能需求，即提供什么样的服务（OO的分解：子系统、模块名称） 过程视图 非功能需求，过程分解（并发、进程、通讯、容错…） 物理视图 从软件到硬件的映射（硬件部署） 开发视图 子系统组件的类型（开发所得部件的显示） 场景视图 汇总，用例的实例（软件产品对架构的需求） 3.题目 在“4+1”视图模型中，__的体系结构关注的是从软件到硬件的映射；__描述了系统的动态结构A.逻辑视图 B.开发视图 C.进(/过)程视图 D.场景视图 E.物理视图 (E,C) 开发人员要从数以万计的小构件中选取要重用的构件(之前有过，X) 由于考虑到提升通用性，所以被重用的代码构件速度太低(√) 只要建立可重用构件库就会促使构件重用(X) 4.XML(1)与HTML的区别 目标 :HTML的设计目标是显示数据，焦点是数据外观，而XML的设计目标是描述数据，焦点是数据的内容，它的显示形式靠CSS或XSL帮助完成。 语法：HTML的标记不是所有的都需要成对出现，XML则要求所有的标记必须成对出现；HTML标记不区分大小写，XML则大小敏感，即区分大小写。 更新：XML允许粒度更新，不必在XML文档每次有局部改变时都发送整个文档的内容，只有改变的元素才必须从服务器发送到客户机，而HTML却不支持这样的功能 标签的定义：XML的标记由架构或文档的作者定义，并且是无限制的。HTML的标记则是预定义的;HTML 作者只能使用当前 HTML 标准所支持的标记。 (2)语法 HTML的语法（较随意） XML的语法(简明) 有起始标签是否必须出现结束标签/关闭标签 未必，例如HTML中的标签 是 标签大小写意义是否相同 相同 不同 标签嵌套顺序是否不能错 无所谓 是 是否必须要有根元素 无所谓 是 属性值是否必须加“” 加不加都可以 是 空格是否被保留 裁减为一个空格 均被保留 所有的特性是否必须有值 未必，如nowrap特性 是 (3)XML语法找错 &lt;/vendor&gt;大小写不对 第五行没有关闭标签&lt;/Name&gt; &lt;/Price&gt;位置不对 五.SA设计1.设计原理(1)耦合和内聚原理★★★ 模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 内聚性是模块内部的相互依赖程度 耦合度等级划分： | 耦合度 | 描述 || :—: | :————————-: || 非直接耦合 | 两模块之间的联系完全是通过主模块的控制和调用来实现的 || 数据耦合 | 一个模块访问另一模块，通过简单数据参数来交换信息 || 标记耦合 | 一组模块通过参数表传递记录信息，这个记录不是简单变量 || 控制耦合 | 一个模块通过传递开关、标志、名字等控制信息控制另一模块 || 外部耦合 | 一组模块都访问同一全局简单变量 || 公共耦合 | 一组模块都访问同一个公共数据环境 || 内容耦合 | 一个模块直接修改另一模块的数据，或直接转入另一个模块 | 内聚度等级划分： | 内聚类型 | 描述 || :–: | :————————: || 功能内聚 | 完成一个单一功能，各部分协同工作，缺一不可 || 顺序内聚 | 处理元素相关，必须顺序执行 || 通信内聚 | 所有处理元素集中在一个数据结构的区域上 || 过程内聚 | 处理元素相关，必须按照特定的次序执行 || 瞬时内聚 | 所包含的任务必须在同一时间间隔内执行(如初始化模块) || 逻辑内聚 | 完成逻辑上相关的一组任务 || 偶然内聚 | 完成一组没有关系或松散关系的任务 | 习题 模块间的耦合度是指模块之间的依赖关系，其中不包括哪个关系？D A.控制关系 B.调用关系 C.数据传递关系 D.继承关系 耦合度最高的是内容耦合，应该尽量采用。(X尽量避免) 使用设计模式，将不用再考虑软件体系结构的现有的解决方案，因为模式自身就包含解决方案。(X) SA设计的重要性体现在它包括了早期的设计决定，体现了系统的全局结构，极大地影响整个系统的质量。(√) (2)抽象原理★★ 抽象是人们透过事务繁杂的表面现象，揭示事物本质特征的方法，也是软件体系结构设计中要用到的基本原理。 抽象可分为两类： 过程抽象：任何一个具体的操作序列，若他们完成一项逻辑意义上的功能，则其使用者都可以把它看做一个单一的逻辑概念。 数据抽象：将数据类型和施加于该类型对象的上的操作作为整体来定义，并限定了对象的值只能通过使用这些操作修改和观察。 抽象是封装的基础，有助于处理系统复杂性，有助于减少部件耦合，有助于接口与实现分离。 (3)封装原理★★ 封装是将事物的属性和行为结合在一起，并且保护事物内部信息不受破坏的一种方式。封装使不同的抽象之间有了明确的界限。 封装有助于非功能特性的实现，例如可变性和可重用性。 封装由两方面组成： 内部构成 操作服务 封装与信息隐藏之间有着密切的联系，封装为信息隐藏提供了支持。 (4)信息隐藏原理★★ 信息隐藏对用户隐藏了部件的实现细节。因此，可以用来更好的处理系统的复杂性和减少各模块之间的耦合。 (5)模块化原理★ 模块化主要关心的是如何将一个软件系统分解成多个子系统和部件。 在体系结构设计中，如果注重了模块化的概念就可以限制更改设计所造成的影响范围。 (6)注意点分离原理★ 不同的和无关联的责任应该出现在系统不同的部件中，让他们相互独立的分离开来。 相互协作完成某一个特定任务的部件也应该和在其他任务中执行的计算部件分离开来。 如果一个部件在不同的环境下扮演着不同的角色，在部件中这些角色应该独立且相互分离。 (7)接口和实现分离原理★★ 在软件体系结构中，任何一个部件都包括了两个部分：接口和实现。 接口部分给出了部件所提供的功能的定义，并对功能的使用方法进行了规范。部件的客户可以访问接口。 实现部分包括了实际代码，对部件的客户不可用。 接口和实现分离的部件更容易在系统中进行改变，尤其是不影响接口的改变，比如性能的提升。 (8)分而治之原理★ 将大问题分解成小问题，经常用作注意点分离原理的方法。(横向分割) (9)层次化原理★ 纵向分割复杂的问题。原理和优缺点同层次系统风格。 题目 一个模块内包含的信息，对于不需要这些信息的模块是不能访问的，这体现了多个设计原理的共同要求。(√) 耦合度最高的是内容耦合，应该尽量采用。(X) 对接口和实现分离原理的贯彻，可以保证用户在使用方式与习惯不变的情况下，享受运行性能的提升。(√改实现不改接口) 2.元模型 元模型是对各种体系结构设计模型的抽象。 需求规格说明用来表示规格说明，该规格说明描述了所要开发的体系结构的系统需求。 解决方案抽象定义了体系结构中(子)结构的概念表示。 体系结构描述定义了软件体系结构的规格说明。 题目 各种不同的体系结构设计方法都可以描述成元模型的实例，只是在过程的顺序及概念的特定内容上有所不同。(√) 元模型中，需求规格说明关注SA中子系统和模块的需求，而解决方案抽象关注SA的系统需求。(X相反)需求规格说明关注SA的系统需求，解决方案抽象关注SA中子系统和模块的需求。 用例的使用在IBM RUP中被推崇备至，整个RUP流程都被称作是“用例驱动”(Use-Case Driven)的。(√) 六.基于SA的软件开发过程1.SA设计在开发过程中的位置地位 软件体系结构设计是软件需求与软件设计之间的桥梁。 2.F16例子对导出SA需求有什么借鉴 分析体系结构需求的三个来源，即系统的质量目标、系统的业务目标、将在该系统上工作的人员的业务目标（人员目标很重要）。 需求来自于许多系统相关人员，尤其是直接使用者。 应综合考虑质量属性（需求要具体）。 3.瓦萨号 导出体系结构需求—— 体系结构需求的三个来源——质量目标★、业务目标、人员目标 特定质量场景 系统相关人员中应有评估、监理专家团队 进行SA设计—— 体系结构的构造（功能构造） 验证——首选质量场景 开发过程分析 基于体系结构的软件开发过程六个步骤： 导出体系结构需求 ==设计体系结构== ==文档化体系结构== ==分析体系结构== 实现体系结构 维护体系结构 2 、 3 、 4步可以重复执行 每个步骤都包括：输入（包括收集此信息的手段）、验证活动、输出。 瓦萨号的例子告诉我们—— 妄想实现所有需求，只会产生脆弱的一无是处的架构。另外，比起仅仅满足客户所要求的功能，软件的成功更为重要。 举例说明——设计出来的新系统虽然满足了技术上的规范，但并没有达到客户可接受的程度。用户总是抱怨用户界面运行缓慢，并且新的数据文件所占用的磁盘空间太大。是什么导致了用户期望与产品实际性能之间的期望差异？ ——==对质量属性的权衡取舍工作没做好== 七.SA评估1.质量属性 产品的易用程度，执行速度，可靠性；当发生异常情况时，系统如何处理。这些被称为==软件质量属性==(或质量因素)的特性，是系统非功能（也叫非行为）部分的需求。 质量属性——是一个组件或一个系统的非功能性特征，提供了测量和分析质量的上下文。 具体的质量属性包括了性能、可靠性、可用性、安全性、可修改性、功能性、可变性、可集成性、互操作性等等。 对各质量属性的区分（用户） 有效性——指的是在预定的启动时间中，系统真正可用并且完全运行时间所占的百分比 工作日期间，在当地时间早上6点到午夜，系统的有效性至少达到9 9 . 5 %，在下午4点到6点，系统的有效性至少可达到9 9 . 9 5 % 效率——是用来衡量系统如何优化处理器、磁盘空间或通信带宽的（ Davis 1993）。如果系统用完了所有可用的资源，那么用户遇到的将是性能的下降，这是效率降低的一个表现。 在预计的高峰负载条件下， 1 0 %处理器能力和1 5 %系统可用内存必须留出备用。 灵活性——就像我们所知道的可扩充性、增加性、可延伸性和可扩展性一样，灵活性表明了在产品中增加新功能时所需工作量的大小。 一个至少具有6个月产品支持经验的软件维护程序员可以在一个小时之内为系统添加一个新的可支持硬拷贝的输出设备。 完整性——完整性（或安全性）主要涉及：防止非法访问系统功能、防止数据丢失、防止病毒入侵并防止私人数据进入系统。 只有拥有查账员访问特权的用户才可以查看客户交易历史。 互操作性——表明了产品与其它系统交换数据和服务的难易程度。 化学制品跟踪系统应该能够从C h e m i D r a w和C h e m - S t r u c t工具中导入任何有效化学制品结构图。 可靠性——是软件无故障执行一段时间的概率（Musa, Iannino and Okumoto 1987）。健壮性和有效性有时可看成是可靠性的一部分。 由于软件失效引起实验失败的概率应不超过5‰ 健壮性——指的是当系统或其组成部分遇到非法输入数据、相关软件或硬件组成部分的缺陷或异常的操作情况时，能继续正确运行功能的程度。 所有的规划参数都要指定一个缺省值，当输入数据丢失或无效时，就使用缺省值数据。 可用性——也称为“易用性”和“人类工程”，它所描述的是许多组成“用户友好”的因素。可用性衡量准备输入、操作和理解产品输出所花费的努力。 一个培训过的用户应该可以在平均3分钟或最多5分钟时间以内，完成从供应商目录表中请求一种化学制品的操作。 对各质量属性的区分（开发者和维护者） 可维护性——表明了在软件中纠正一个缺陷或做一次更改的简易程度。可维护性取决于理解软件、更改软件和测试软件的简易程度，可维护性与灵活性密切相关。 在接到来自联邦政府修订的化学制品报告的规定后，对于现有报表的更改操作必须在一周内完成。 可移植性——是度量把一个软件从一种运行环境转移到另一种运行环境中所花费的工作量。 该应用软件系统各个模块都可以在x86机器上运行，且其中的大部分功能模块也可以在iMac机器上运行，剩下的少量功能模块经修改后，也可在iMac机器上运行。 可重用性——从软件开发的长远目标上看，可重用性表明了一个软件组件除了在最初开发的系统中使用之外，还可以在其它应用程序中使用的程度。 设计单机版媒体播放器系统时，还要保证核心的播放模块可以在将来开发的联机版媒体播放器系统中使用。 可测试性——指的是测试软件组件或集成产品时查找缺陷的简易程度。 随着图形引擎功能的不断增强，我们需要对它进行多次测试，所以作出了如下的设计目标：“一个模块的最大循环复杂度不能超过2 0。” 2.几种评估方式以及各自的特点 基于调查问卷、检查表 自由灵活，但因人而异——主观性强 基于场景★★ SEI at CMU的评估方法 基于度量★ 能提供更为客观和量化的质量评估，不过需要在SA设计基本完成之后进行——较客观 ==评估过程=论证SA对关键场景的支持程度== 3.SAAM/ATAM(1)SAAM软件体系结构分析法 SAAM法仅仅考虑场景和体系结构的关系，也不涉及太多的步骤和独特的技术。是一种理想的入门方法。 SAAM法实质上是对检查表法的进一步完善，它首先把要检查的事物的属性列举出来，再对各个属性进行”检查”，使思路更广，目标更明确。 SAAM分析评估体系结构的过程包括6个步骤: 通过风险承担者协商讨论，开发一些任务场景，体现系统所支持的各种活动。(场景生成) 用一种易于理解的、合乎语法规则的体系结构描述SA，体现系统的计算构件、数据构件以及构件之间的关系。(体系结构描述) 区分直接场景（不需要修改SA的场景）和间接场景，设置优先级（从重要到次要）。(场景的分类和优先级确定) 对于间接场景，要估计修改SA以实现它的代价。(间接场景的单独评估) 通过对场景交互（多个间接场景要求更改同一个组件）的分析，能得出系统中所有场景对系统中的构件所产生的影响的列表。(对场景关联的评估) 对场景和场景间的交互作一个总体的权衡和评价，设置权值，得出总体评价。(形成总体评估) (2)ATAM体系结构权衡分析法 ATAM是评价软件构架的一种综合全面的方法。这种方法不仅可以揭示出构架满足特定质量目标的情况，而且（因为它认识到了构架决策会影响多个质量属性）可以使我们更清楚地认识到质量目标之间的联系——即如何权衡诸多质量目标。 体系结构的敏感点和权衡点 敏感点：会被某些体系结构元素显著影响的系统模型的属性值。 权衡点：系统内与几个敏感点都相关的地方。 ATAM的评估步骤]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法作业三]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%B8%89%2F</url>
      <content type="text"><![CDATA[第三次作业71115115 王子卓3-11234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ZuiChangDanDiaoDiZengZiXuLie &#123; public int[] ZCDDZDZXL(int[] a)&#123; int i=1,j=0,k=0,n=a.length; int[] b = new int[n]; //b数组的各个元素负责存储以a数组中序号对应的各个元素为结尾的最长单调子序列长度 b[0] = 1; for(;i&lt;n;i++)&#123; for(;j&lt;i;j++)&#123; if(a[j]&lt;=a[i]&amp;&amp;k&lt;b[j]) k=b[j]; &#125; b[i] = k+1; &#125; return maxLength(n, b); &#125; public int[] maxLength(int n,int[] b)&#123; int temp=0,i=0,flag=0; for(;i&lt;n;i++)&#123; if(b[i]&gt;temp)&#123; temp=b[i]; flag = i; &#125; &#125; int[] msg = new int[2]; msg[0] = flag; msg[1] = temp; return msg; &#125; public static void main(String[] args) &#123; ZuiChangDanDiaoDiZengZiXuLie xuLie = new ZuiChangDanDiaoDiZengZiXuLie(); int[] a = &#123;0,1,2,3,4,3,5&#125;; int[] length = xuLie.ZCDDZDZXL(a); System.out.println("子序列末尾元素角标"+length[0]+"\n最长单调递增子序列长度"+length[1]); int biggest=0; for(int i=0;i&lt;length[0]+1;i++)&#123; if(i==0)&#123; System.out.println(a[i]); biggest = a[i]; &#125;else if(a[i]&gt;=biggest)&#123; System.out.println(a[i]); biggest = a[i]; &#125; &#125; &#125;&#125; 3-2123456789101112131415161718192021222324252627public class AdvancedZCDDDZZXL &#123; public int LIS(int[] a)&#123; int[] b = new int[a.length]; b[1] = a[0]; int k = 1; for(int i=1;i&lt;a.length;i++)&#123; if(a[i]&gt;=b[k])&#123; b[++k] = a[i]; &#125;else&#123; b[binary(i, k, a, b)] = a[i]; &#125; &#125; return k; &#125; public int binary(int i,int k,int[] a,int[] b)&#123; if(a[i]&lt;b[1]) return 1; int j=k; for(int h=1;h!=j-1;)&#123; if(b[k=(h+j)/2]&lt;=a[i]) h=k; else j=k; &#125; return j; &#125;&#125; 3-4 该问题是二维0-1背包问题。 对于给定的$$c&gt;0,d&gt;0,\omega_i&gt;0,b_i&gt;0,v_i&gt;0, 1\le{i}\le{n}$$ 要求找出n元0-1向量$$(x_1,x_2,…,x_n),xi\in{0,1},1\le{i}\le{n}$$使得$$\sum{i=1}^{n}\omega_ixi\le{c}, \sum{i=1}^nb_ixi\le{d}$$而且使$$\sum{i=1}^nv_ix_i$$达到最大值。 由此可知，二维0-1背包问题是整数规划问题。$$max\sum_{i=1}^{n}v_ixi\\left{\begin{array}\\sum{i=1}^{n}\omega_ixi\le{c}\\sum{i=1}^{n}b_ix_i\le{d}\x_i\in{0,1},1\le{i}\le{n}\end{array}\right.$$ 该问题具有最优子结构性质。设该问题的子问题$$max\sum_{t=i}^{n}v_txt\\left{\begin{array}\\sum{t=i}^{n}\omega_txt\le{j}\\sum{t=i}^{n}b_tx_t\le{k}\x_i\in{0,1},i\le{t}\le{n}\end{array}\right.$$ 的最优解为$$m(i,j,k)$$，背包容量为j，容积为k，可选择的物品为$$i,i+1,…,n$$时该问题的最优值。 由二维0-1背包问题的最优子结构性质，可得：$$m(i,j,k)=\left{\begin{array}\max{m(i+1,j),m(i+1,j-\omega_i,k-b_i)+v_i}\ \ \ \ j\ge\omega_i且k\ge{b_i}\m(i+1,j)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0\le{j}\le{\omega_i}或0\le{k}\le{b_i}\end{array}\right.$$ $$m(n,j,k) =\left{\begin{array}\v_n \ \ \ \ \ j\ge{\omega_n}且k\ge{b_n}\0 \ \ \ \ \ \ \ 0\le{j}&lt;{\omega_n}或0\le{k}&lt;b_n\end{array}\right.$$ 由上式可知$$m(n,c,d)$$为最优值。算法所需的计算时间为$$O(ncd)$$。 4-1 设变量$$x_i=1$$表示将$$l_i$$存放在$$T_1$$上，并且$$T_1$$的检索时间短于$$T2$$$$\sum{i=1}^{n}l_ixi\le\sum{i=1}^{n}l_i(1-xi)\\sum{i=1}^{n}l_ixi\le\frac{1}{2}\sum{i=1}^{n}l_i$$ $$T1$$的检索时间应取最大值，即$$max\sum{i=1}^{n}l_ixi\使得\sum{i=1}^{n}l_ixi\le\frac{1}{2}\sum{i=1}^{n}l_i$$ 最小生成树算法的正确性Prim算法 Prim算法的思路是，从任意一个顶点开始，把这个顶点作为最初的最小生成树的子树，通过逐步地为当前的子树添加新边来生成最终的最小生成树，添加的策略是，每次只添加从外部连接到该子树的所有边中的最短边。 对于任意一个顶点vi，连接到该顶点的所有边中的一条最短边$$(v_i,v_j)$$必然属于最小生成树。 假设最小生成树已经建成，$$(v_i,v_j)$$是连接到顶点vi的最短边，在最小生成树中取出vi，断开连接到vi的边，则生成树被拆分成 顶点$$v_i$$ 顶点$$v_j$$所在的连通分量（单独一个顶点也看作一个独立的连通分量） 其余若干个连通分量（个数大于等于0） 三个部分 现在要重建生成树，就要重新连接之前被断开的各边。 虽然不知道之前被断开的都是哪几条边，但是可以通过这样一个简单的策略来重建连接：将$$v_i$$分别以最小的成本逐个连接到这若干个互相分离的连通分量。具体来说，就是要分别遍历顶点$$v_i$$到某个连通分量中的所有顶点的连接，然后选择其中最短的边来连接$$v_i$$和该连通分量；而要将$$v_i$$连接到$$v_j$$所在的连通分量，显然通过边$$(v_i,v_j)$$连接的成本最低，所以边$$(v_i,v_j)$$必然属于最小生成树（如果连接到$$v_i$$的最短边不止一条，只要任意挑选其中的一条$$(v_i,v_j)$$即可，以上的证明对于这种情况同样适用）。这样我们就为原来只有一个顶点$$v_i$$的子树添加了一个新的顶点vj及新边$$(v_i,v_j)$$。接下来只要将这棵新子树作为一个连通子图，并且用这个连通子图替换顶点$$v_i$$重复以上的分析，迭代地为子树逐个地添加新顶点和新边即可。 Kruskal算法 Kruskal算法通过从小到大遍历边集，每次尝试为最小生成树加入当前最短的边，加入成功的条件是该边不会在当前已构建的图中造成回路，当加入的边的数目达到n-1，遍历结束。 Kruskal算法每次为当前的图添加一条不会造成回路的新边，其本质是逐步地连接当前彼此分散的各个连通分量（单个顶点也算作一个连通分量），而连接的策略是每次只用最小的成本连接任意两个连通分量。这个策略之所以能够实现，是因为每加入一条边之后只会出现两种结果： 在已有的连通分量中形成回路 连接两个彼此独立的连通分量 所以，通过从小到大遍历边集，判断是否会造成回路，然后逐条添加新边就可以实现上诉的连接策略。 如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树当最小生成树被拆分成彼此独立的若干个连通分量的时候，因为该边必然是这两个连通分量的可以连接到外部的最短边，所以所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树。 由此也就证明了，Kruskal算法通过每次以最小的成本来连接两个连通分量的策略确实可以正确地生成最小生成树。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法作业二]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[第二次作业71115115 王子卓2-2(1)left和right游标的调整不正确，应改为：12if(x&gt;a[middle]) left = middle+1;else right = middle-1; (2)left和right游标的调整不正确，查找元素为x=a[n-1]时错误。(3)同上，查找元素为x=a[n-1]时错误。(4)left和right游标的调整不正确，查找大于中值的数时可能进入死循环。(5)没什么问题(6)left和right游标的调整不正确，查找元素为x=a[n-1]时错误。(7)left和right游标的调整不正确，查找元素为x=a[0]时错误。2-31234567891011121314template&lt;class T&gt;int binarySearch(T a[], const T &amp;x, int left, int right, int &amp;i, int j) &#123; int middle; while(left&lt;=right)&#123; middle = (left+right)/2; if(x==a[middle])&#123; i=middle;j=middle;return middle; &#125; if(x&gt;a[middle]) left = middle+1; else right = middle-1; &#125; i=right;j=left;return -1; &#125; 2-4当m远小于n时，可以将大整数v分成n/m个长度为m的小段。计算u*v需要计算n/m次m位乘法，每一次m位乘法采用分治法计算，需要$$O(m^{log_23})$$时间。总时间为$$O(\frac{n}{m}m^{log_23})=O(nm^{log_2{\frac{3}{2}}})$$ 算法实现2-6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.FileReader;import java.io.OutputStreamWriter;public class Zidianxu &#123; String input = "/home/wang/input.txt"; String output = "/home/wang/output.txt"; public void write(String string)&#123; //作用就是将传入的字符串写入指定的文件 try &#123; FileOutputStream fileOutputStream = new FileOutputStream(output,false);//覆写模式 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,"UTF-8"); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.write(string); bufferedWriter.flush(); bufferedWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public int jieCheng(int i)&#123; //求阶乘 int result=1; for(int j=2;j&lt;=i;j++)&#123; result*=j; &#125; return result; &#125; public char[] next(char[] s)&#123; //求下一个排列 char[] result=s; int last = s.length-1; for(int i=last-1;i&gt;=0;i--)&#123; if(s[i]&lt;s[last])&#123; //最右边的数，从右往左，遇到第一个比它小的数时， //排列到这个数的前面，这个数以后依次后移一位。 char temp = s[last]; for(int j=last-1;j&gt;=i;j--)&#123; result[j+1] = result[j]; &#125; result[i] = temp; break; &#125; &#125; return result; &#125; public void read()&#123; try &#123; File file = new File(input); BufferedReader reader = new BufferedReader(new FileReader(file)); String string = null,out = ""; int i=0,nums=0,value=0,current=0,nums2=0; //i是行数计数，nums是排列的长度，value是字典序值 //current是当前指向的数字，nums2只是复制一下nums while((string = reader.readLine()) != null)&#123; if(i==0)&#123; nums = Integer.parseInt(string); nums2=nums; &#125; else&#123; //以26458173为例，选定一个数 //看后面有几个比当前数小的，比如2后面比2小的只有1个， //6后面比6小的有4个，4后面比4小的有2个 //8227=1*7!+4*6!+2*5!+... char[] array = string.toCharArray(); for(;current&lt;nums-1;current++)&#123; //从零下标开始依次往后扫描 //counter用来数比这个数小的有几个数 int scan = current+1,counter=0; for(;scan&lt;nums;scan++)&#123; if(array[current]&gt;array[scan])&#123; counter++; &#125; &#125; value+=counter*jieCheng(nums2-1-current); &#125; out+=value+"\n"; char[] result = next(array); String result2 = String.valueOf(result); out+=result2; &#125; i++; &#125; write(out);//写出 reader.close();//关闭BufferedReader &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Zidianxu zidianxu = new Zidianxu(); zidianxu.read(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法作业一]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%B8%80%2F</url>
      <content type="text"><![CDATA[第一次作业71115115 王子卓1-1 求下列函数的渐进表达式$$3n^2 + 10n = O(n^2)$$ $$\frac{n^2}{10} + 2^n = O(2^n)$$ $$21 + \frac{1}{n} = O(1)$$ $$log(n^3) = O(logn)$$ $$10log3^n = O(n)$$ 1-4(1)设在这台新机器上用同一算法在 t 秒内能解规模为$$n_1$$的问题$$32^n64 = 3*2^{n_1}$$ $$n_1 = n + 6$$ (2)设在这台新机器上用同一算法在 t 秒内能解规模为$$n_2$$的问题$$n^2*64 = n_2^2$$ $$n_2 = 8*n$$ (3)T(n) = 8与n无关，所以可以解输入规模任意大的问题。 1-6(1)$$f(n) = logn^2 = 2*logn$$ $$g(n) = logn+5$$ f(n)与g(n)同阶，因此$$f(n) = \theta(g(n))$$ (2)$$f(n) = logn^2 = 2*logn$$ $$g(n) = \sqrt[2]{n} = n^{\frac{1}{2}}$$ $$log_2n$$的反函数为$$2^n$$，而$$\sqrt[2]{n}$$的反函数为$$n^2$$，$$2^n$$的增长速度远高于$$n^2$$，因此$$log_2n$$的增长速度远小于$$\sqrt[2]{n}$$.因此f(n)的阶不高于g(n)的阶，也就是$$f(n) = O(g(n))$$ (3)$$f(n) = n$$ $$g(n) = log^2n$$ $$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(log_2^2n)&lt;O(nlog_2n)$$ $$f(n) = \Omega(g(n))$$ (4)$$f(n) = nlog_2n + n = O(nlog_2n)$$ $$g(n) = log_2n = O(log_2n)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (5)$$f(n) = 10 = O(1)$$ $$g(n) = log10 = O(1)$$ f(n)与g(n)同阶，因此$$f(n) = \theta(g(n))$$ (6)$$f(n) = O(log^2n)$$ $$g(n) = O(logn)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (7)$$f(n) = 2^n = O(2^n)$$ $$g(n) = 100n^2 = O(n^2)$$ f(n)的阶不低于g(n)的阶，因此$$f(n) = \Omega(g(n))$$ (8)$$f(n) = O(2^n)$$ $$g(n) = O(3^n)$$ f(n)的阶不高于g(n)的阶，因此$$f(n) = O(g(n))$$ 算法实现1-21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package first;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.FileReader;import java.io.OutputStreamWriter;public class ZiDianXuShengXu &#123; int lines=0,count=0; String input = "/home/wang/dict.txt"; String output = "/home/wang/dict2.txt"; public void write(String string)&#123; //作用就是将传入的字符串写入指定的文件 try &#123; FileOutputStream fileOutputStream = new FileOutputStream(output,false);//覆写模式 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,"UTF-8"); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.write(string); bufferedWriter.flush(); bufferedWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void read()&#123; try &#123; File file = new File(input); BufferedReader reader = new BufferedReader(new FileReader(file)); String string = null,out = ""; int i=0,lines=0; while((string = reader.readLine()) != null)&#123; if(i==0) lines = Integer.parseInt(string); //我想了想，好像不需要，所以就没用 else&#123; int sum=0; char temp = string.charAt(string.length()-1);//取出字符串最后一位 sum = temp - 96 - string.length() + 1;//先把最后一位加上 for(int j=0;j&lt;string.length()-1;j++)&#123;//分别计算每一位 temp = string.charAt(j); sum += (temp-96-j)*(26-j);//每一位进制不同 &#125; out+=sum+"\n"; &#125; i++; &#125; write(out);//写出所有的编码 reader.close();//关闭BufferedReader &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ZiDianXuShengXu ziDianXuShengXu = new ZiDianXuShengXu(); ziDianXuShengXu.read(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统实验一]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
      <content type="text"><![CDATA[向Linux内核增加一个系统调用71115115 王子卓 2017年3月14日一.实验目的 通过实验，熟悉Linux操作系统的使用，掌握构建与启动Linux内核的方法；掌握用户程序如何利用系统调用与操作系统内核实现通信的方法，加深对系统调用机制的理解；进一步掌握如何向操作系统内核增加新的系统调用的方法，以扩展操作系统的功能。 二.实验内容 Linux环境下的C或C++编译和调试工具的使用。 向Linux内核增加新的系统调用，系统调用名称和功能自行定义，但必须实现如下输出功能：“My Student No. is 71115115，and My Name is 王子卓”。 Linux新内核的编译、安装和配置。 编写应用程序以测试新的系统调用并输出测试结果。 三.实验步骤 下载Linux内核 1sudo apt install linux-source-4.4.0 下载完的内核放在/usr/src/里，等待解压。 解压内核 12cd /usr/src/sudo tar -xvf ./linux-source-4.4.0.tar.bz2 解压完成之后增添系统调用 增添系统调用 编辑arch/x86/entry/syscalls/syscall_64.tbl 12cd ./linux-source-4.4.0/sudo nano ./arch/x86/entry/syscalls/syscall_64.tbl 我添加了546号系统调用sys_hello 1546 64 hello sys_hello 声明系统函数调用原型 编辑include/linux/syscalls.h 1sudo nano include/linux/syscalls.h 添加系统调用函数原型 1asmlinkage long sys_hello(void); 添加系统调用函数的定义 编辑kernel/sys.c 1sudo nano kernel/sys.c 添加系统调用函数的定义 1234asmlinkage long sys_hello(void)&#123; printk("My student NO. is 71115115, and my name is 王子卓"); return 1;&#125; 编译内核 首先要安装编译所需工具 1sudo apt install libncurses-dev libssl-dev 安装完开始编译内核 1234567sudo make menuconfigsudo make bzImage //在bzImage之前加上 -j2 、 -j4等选项可以选择编译的线程数sudo make modulessudo make modules_installsudo make install //引导自动添加sudo update-grub //保险起见再次更新grub2sudo restart 重启后进入新内核。 测试系统调用 1234567891011//syscall.cpp#include&lt;stdio.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main()&#123; long int call = syscall(546); printf("System call sys_hello returned %ld\n",call); return 0;&#125; 四.主要数据结构及其说明 系统调用表syscall_64.tbl，记录着所有系统调用号。 系统调用头文件syscalls.h，记录着所有系统调用的函数原型。 系统调用定义文件sys.c，记录着所有系统调用的函数实现。 五.程序运行结果 六.实验体会 12345678910111213141516scripts/sign-file.c:23:30: fatal error: openssl/opensslv.h: No such file or directorycompilation terminated.scripts/Makefile.host:91: recipe for target &apos;scripts/sign-file&apos; failedmake[1]: *** [scripts/sign-file] Error 1make[1]: *** Waiting for unfinished jobs.... CC arch/x86/purgatory/purgatory.o AS arch/x86/purgatory/stack.o AS arch/x86/purgatory/setup-x86_64.o CC arch/x86/purgatory/sha256.oMakefile:566: recipe for target &apos;scripts&apos; failedmake: *** [scripts] Error 2make: *** Waiting for unfinished jobs.... AS arch/x86/purgatory/entry64.o CC arch/x86/purgatory/string.o LD arch/x86/purgatory/purgatory.ro BIN2C arch/x86/purgatory/kexec-purgatory.c 这是因为缺少编译所需的libssl-dev库 解决方法：sudo apt install libssl-dev 123456****** Configuration file &quot;.config&quot; not found!****** Please run some configurator (e.g. &quot;make oldconfig&quot; or*** &quot;make menuconfig&quot; or &quot;make xconfig&quot;).*** 这是在编译之前没有执行sudo make menuconfig生成.config文件。 七.源程序123456789101112131415161718192021222324252627sudo nano ./arch/x86/entry/syscalls/syscall_64.tbl//末尾添加546 64 hello sys_hellosudo nano include/linux/syscalls.h//任意位置添加asmlinkage long sys_hello(void);sudo nano kernel/sys.c//任意位置添加asmlinkage long sys_hello(void)&#123; printk("My student NO. is 71115115, and my name is 王子卓"); return 1;&#125;//测试系统调用//syscall.cpp#include&lt;stdio.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main()&#123; long int call = syscall(546); printf("System call sys_hello returned %ld\n",call); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最简单地安装PyQt5+Eric6+Sip+QScintilla2]]></title>
      <url>%2F2017%2F01%2F12%2F%E6%9C%80%E7%AE%80%E5%8D%95%E5%9C%B0%E5%AE%89%E8%A3%85PyQt5-Eric6-Sip-QScintilla2%2F</url>
      <content type="text"><![CDATA[对编译安装说不&emsp;&emsp;编译安装不利于后续升级，也有可能在编译过程中出现各种奇怪的问题，最主要还有对于低端机来说很慢。。。 Ubuntu安装1234567891011sudo apt install python3.5 python3-pip //基础sudo pip3 install qscintilla //这一步会安装PyQt5、Sip、QScintilla2sudo apt install qt4-designer //Eric会用它来创建界面//到官网上下载Eric的压缩包，解压缩，cd到解压目录sudo python3 install.py //安装Eric6sudo python3 install-i18n.py //安装语言包sudo python3 install-debugclients.py //不知道是干嘛的，安装上没坏处sudo pip3 install pyenchant //Python检查拼写的插件，Eric会用上//之后就完成了，比我看到的任何教程都简单。。。//好好研究一下PyQt5吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java大作业说明文档]]></title>
      <url>%2F2017%2F01%2F07%2FJava%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[GitHub ATM机设计文档71115115 王子卓 效果 &emsp;&emsp;服务器的守护进程启动之后可以显示在线人数和各个用户的账户总金额。&emsp;&emsp;ATM机界面在没有登录的时候不可以点击存取款、查询等按钮，金额、编号文本框不可编辑。登陆之后，注册和登录按钮不可点击，用户名、密码文本框不可编辑。 测试方法&emsp;&emsp;修改Server.java中getConnection函数中的dbURL，将&amp;user=root&amp;password=******修改成您的MySQL用户名和密码。 程序结构 &emsp;&emsp;这不是一个标准的UML类图。&emsp;&emsp;活期账户、半年期、一年期、五年期存款和贷款都实现了同一个Balance接口，Balance接口继承了Runnable类。活期账户、半年期、一年期、五年期存款和贷款都聚合到User类中。客户端Client和服务器Server都有User类的成员对象。&emsp;&emsp;客户端Client和服务器守护进程ServerDaemon连接，由ServerDaemon动态创建Server线程。&emsp;&emsp;每一笔存款自身都是线程，服务器打开之后，线程自动运行，实现加息。利息每季度结算，每季度利息是年利率开四次方。&emsp;&emsp;客户端和服务器之间信息传递依靠对象输入输出流，信息载体是Command类对象和User类对象。&emsp;&emsp;数据库的操作由Server类完成。&emsp;&emsp;大部分对象都实现了可序列化Serializable接口，以便存入数据库。&emsp;&emsp;采用了UTF-8编解码，所以支持中文。 数据库结构 数据库名：atm 数据表名：user 数据表字段： name：varchar(200),非空，不可重复 object：longblob，非空 字段作用：name负责存储用户的用户名。object负责存储用户类的对象，该对象中保存有包括用户密码在内的各种用户信息。 优点：在一定程度上减少数据库的读取、写入次数。用户的信息并不以明文方式呈现，在一定程度上有加密的作用。 程序使用流程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AMD New Horizon]]></title>
      <url>%2F2016%2F12%2F17%2FAMD-New-Horizon%2F</url>
      <content type="text"><![CDATA[AMD New Horizon: 打不开点这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第三版)]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%B8%89%E7%89%88%2F</url>
      <content type="text"><![CDATA[综述&emsp;&emsp;广泛意义上讲，代理是一种类，它的作用是作为其他东西的接口。代理可以成为任何东西的接口：网络连接、内存中的大型对象、文件或者是其他不可复制或复制代价很大的资源。简短来说，代理是被客户端调用，用来访问隐藏的实体服务对象的封装类或代理对象。&emsp;&emsp;代理可以简单地直接调用实体对象，也可以添加额外的逻辑。代理可以提供额外的功能，例如对资源敏感的实体对象进行缓存，或者在调用实体对象之前进行前提检查。&emsp;&emsp;对于客户端而言，使用代理对象和使用实体对象是相似的，因为二者都实现了同一个接口。 可能的应用场景远程代理&emsp;&emsp;在分布式对象通信中，本地对象是远程对象的代理对象。本地对象的方法调用的结果是远程对象的方法被调用。典型例子是ATM，ATM持有远程服务器的实体对象的代理对象。 虚拟代理&emsp;&emsp;在一些情况下，用一个大体框架来代替复杂庞大的对象的优势是很明显的。比如当一幅图片很大时用一个虚拟代理替换它，之后按需加载。 保护代理&emsp;&emsp;保护代理被用来基于访问权限，控制资源的访问。 虚拟代理的实例图片接口1234public interface Image &#123; //图片都可以显示 public void displayImage();&#125; 真实图片类12345678910111213141516public class RealImage implements Image &#123; private String filename = null; //真实图片需要加载 public RealImage(final String name) &#123; this.filename = name; loadImageFromDisk(); &#125; //加载方法 private void loadImageFromDisk()&#123; System.out.println("Loading " + filename); &#125; @Override public void displayImage() &#123; System.out.println("Displaying " + filename); &#125;&#125; 代理图片类12345678910111213141516public class ProxyImage implements Image &#123; private RealImage image = null; private String filename = null; public ProxyImage(final String filename) &#123; this.filename = filename; &#125; @Override public void displayImage() &#123; //懒汉式单例:只有在第一次请求实例的时候创建 if (image == null) &#123; image = new RealImage(filename); &#125; image.displayImage(); &#125;&#125; 测试类1234567891011121314public class ProxyTest &#123; public static void main(String[] args) &#123; Image image1 = new ProxyImage("A"); Image image2 = new ProxyImage("B"); image1.displayImage(); image1.displayImage(); image2.displayImage(); image2.displayImage(); //这一次不用再次加载 image1.displayImage(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用阿里云服务器搭建PPTP协议的VPN]]></title>
      <url>%2F2016%2F12%2F13%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAPPTP%E5%8D%8F%E8%AE%AE%E7%9A%84VPN%2F</url>
      <content type="text"><![CDATA[作为运维，我手上现在有一个位于美国硅谷的阿里云ECS服务器。秉承物尽其用的原则，正好搭建一个VPN服务器。 环境介绍 CPU：1核心Haswell架构的处理器 内存：1GB+自己配置的4GB的Swapfile(相当于虚拟内存) 操作系统：Ubuntu14.04LTS 64位 准备工作Linux平台准备12345//安装openssh-clientsudo apt install openssh-client//连接服务器//例如ssh root@127.0.0.1 //ssh 用户名@服务器的公网IP Windows平台准备 安装PuTTY或者XShell，想要更傻瓜操作一点可以安装WinSCP供后续使用 使用PuTTY或者XShell连接服务器 安卓平台准备我就是用我的小米4C上软工课无聊配置得VPN哈哈哈哈，所以我也写一下好了 安装connectBot(详见GitHub) 使用connectBot连接服务器 安装有关软件12//服务器上sudo apt install ppp iptables pptpd 炒鸡简单是吧 更改相关配置更改使用的工具命令行123456vi /file //或者vim//用上下键移动光标到需要修改的那一行，按“i”键进入插入编辑状态，修改完成之后，按“esc”键退出编辑，直接在键盘上输入“:wq&quot;即可保存退出。//好在不一定要用vi/vim，用nano也OKnano /file//上下左右都能移动光标，除了不能用鼠标以外没什么难度。修改完成按Ctrl+X，问是否保存按Y，之后保存名称不用改直接回车。找不到就按Ctrl+W查找就是。 nano的具体操作可以看我使用过的Linux命令之nano - 比vi简单易用的文本编辑器 图形化使用WinSCP以root用户登录，使用WinSCP提供的文本编辑功能双击修改即可。修改完成之后Ctrl+S保存，问你是否覆盖，选是即可。 修改配置文件(以使用nano为例)编辑pptpd.conf1234nano /etc/pptpd.conf//找到#localip 192.168.0.1// #remoteip 192.168.0.234-238,192.168.0.245//删去#号即可 编辑options12345nano /etc/ppp/options//搜索ms-dns，去掉搜索到的两行ms-dns前面的#，并修改为下面的字段//ms-dns 8.8.8.8//ms-dns 8.8.4.4 编辑chap-secrets12345nano /etc/ppp/chap-secrets//添加一行，按照下面格式输入：//用户名 pptpd 密码 *//比如 zizhuo pptpd zizhuo *//*的含义是不限制连接者的IP地址，想要限制的话改成那个IP即可 编辑sysctl.conf(内核文件)1234nano /etc/sysctl.conf//将net.ipv4.ip_forward=0//改成net.ipv4.ip_forward=1 添加iptables转发规则1iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -j MASQUERADE 说明： --table -t table table to manipulate (default: `filter’) --append -A chain Append to chain --source -s address[/mask][…] source specification --out-interface -o output name[+] &emsp;network interface name &emsp;eth1是阿里云服务器的连接外网的网卡，可以用ifconfig看一下哪一块网卡是外网IP就可以 –jump -j target &emsp;&emsp;target for rule (may load target extension) 启动pptpd123sudo service pptpd restart//或者/etc/init.d/pptpd restart 设置开机自启貌似现在默认就可以，不过我还是说一下吧1234//Ubutnu没有chkconfig，可以用rcconfsudo apt install rcconfrcconf on//之后会看到菜单，按空格选择开启/关闭，Tab键跳出选择OK/Cancel 结束去看看所谓的“真实世界”吧2333，下篇文章再见。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[归一化谷歌距离的计算方法]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%BD%92%E4%B8%80%E5%8C%96%E8%B0%B7%E6%AD%8C%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[归一化谷歌距离的计算方法71115115 王子卓 摘要&emsp;&emsp;归一化Google距离（Normalized Google Distance）是一种语义相似性的度量方法，由给定一组关键词集合的Google搜索引擎所返回的命中数量得出。&emsp;&emsp;在自然语言中，具有相同或相似意思的两个关键字在以归一化谷歌距离为单位的情况下趋向于“接近”，意思不同的两个关键字则趋向于“疏远”。本文重点介绍如何使用Java语言和百度搜索引擎实现归一化谷歌距离的计算。&emsp;&emsp;关键字：Normalized Google Distance 、 Java 、百度搜索 1.归一化谷歌距离1.1定义&emsp;&emsp;归一化谷歌距离是以搜索引擎提供的关键字搜索结果数量为计算依据，对语义相似程度的度量方法。&emsp;&emsp;具体而言，两个搜索关键词之间x和y之间的归一化谷歌距离可以用下式表示：&emsp;&emsp;其中：f(x)表示在搜索引擎中搜索x时返回的匹配记录数;f(y)表示在搜索引擎中搜索y时返回的匹配记录数;f(x,y)表示在搜索引擎中搜索词组(x,y)时返回的匹配记录数;M表示搜索引擎总索引量。上式中log均表示自然对数。 1.2分析1.2.1取值范围&emsp;&emsp;NGD(x,y)的取值范围为[0,∞]。如果两个搜索词x和y从未一起出现在同一网页上，而是单独出现时，则他们之间的归一化谷歌距离是无穷。如果两个词总是同时出现，则他们的归一化谷歌距离是0。&emsp;&emsp;一般情况下，NGD(x,y)越接近于0，x、y越相似。如果NGD(x,y)大于等于1，则x、y之间区别很大。&emsp;&emsp;特殊情况下，由于搜索引擎结果不准确，NGD(x,y)可能会小于0。 1.2.2满足规律&emsp;&emsp;在搜索引擎足够准确的情况下 NGD(x,x)等于0，满足同一律。 NGD(x,y)等于NGD(y,x)，满足交换律。 1.2.3尺度不变性&emsp;&emsp;归一化谷歌距离具有尺度不变性。设想如果搜索引擎总的索引量M增长了n倍，那么f(x)、f(y)、f(x,y)也应该增长n倍。这是因为归一化谷歌距离提供给我们搜索关键字之间客观语义联系，当M以一个不确定的比例增长时，NGD(x,y)应该保持稳定。 2.利用百度搜索引擎和Java语言实现谷歌距离的计算2.1设计思路 NormalizedGoogleDistance类 公有静态函数NGD(String a,String b),返回值为Double类型。作用是获取网页的源代码，使用searchResult函数获得三种情况下搜索索引个数，并且将值传递给Calculate函数做计算。 私有静态函数searchResult(String name)，返回值为Double类型。使用正则表达式得到索引个数。 私有静态函数Calculate(Double numA,Double numB,Double numC)，返回值为Double类型。计算并返回归一化谷歌距离的计算结果。 公有静态函数main(String[] args)，返回值为空。接受从命令行传来的两个关键字参数，调用NGD函数计算结果并输出。 2.2具体实现2.2.1主体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.regex.*;public class NormalizedGoogleDistance &#123; static String regex = "百度为您找到相关结果约(.*)个"; static Pattern pattern = Pattern.compile(regex); static String url = "http://www.baidu.com/s?wd="; /** * @param name * @return 搜索到的网页数量 */ private static Double searchResult(String name)&#123; try &#123; URL baiduURL = new URL(url+name); URLConnection connection = baiduURL.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); //逐行筛选匹配正则表达式，并将结果中的逗号删除，之后转化成数字。 String html = in.readLine(); while(html!=null)&#123; Matcher matcher = pattern.matcher(html); while(matcher.find())&#123; System.out.println(name.replaceAll("%20", " ")+": "+matcher.group(1));//格式优化 String temp = matcher.group(1); return Double.parseDouble(temp.replaceAll(",", "")); &#125; html = in.readLine(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0.0;//有可能没有返回值，所以默认写一个0.0 &#125; /** * @param a * @param b * @return The result of NGD */ public static Double NGD(String a,String b)&#123; //删去空格，以防搜索出错 a=a.replaceAll(" ", ""); b=b.replaceAll(" ", ""); //正则表达式匹配个数 //用于存三次搜索各自的索引量 Double numA,numB,numC; numA=1.0;numB=1.0;numC=1.0; try &#123; numA = searchResult(a); numB = searchResult(b); numC = searchResult(a+"%20"+b); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //返回Calculate函数的计算结果 return Calculate(numA, numB, numC); &#125; /** * @param numA * @param numB * @param numC * @return NGD公式计算结果 */ public static Double Calculate(Double numA,Double numB,Double numC)&#123; Double lnx = Math.log(numA); Double lny = Math.log(numB); Double lnSum = Math.log(25270000000.0);//由于不知具体数值，这里取谷歌搜素最大索引限制 Double lnxy = Math.log(numC); //NGD公式 if (lnx&gt;lny) &#123; return (lnx-lnxy)/(lnSum-lny); &#125;else &#123; return (lny-lnxy)/(lnSum-lnx); &#125; &#125; /** * @param args * 从外部传进两个参数作为关键字，并将结果输出 */ public static void main(String[] args) &#123; Double result = NGD(args[0], args[1]); System.out.println("NGD: "+result); &#125;&#125; 2.2.2界面实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.GridLayout;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.UIManager;public class NGDUI &#123; public NGDUI() &#123; //初始化应用标题和标签 JFrame frame = new JFrame("Normalized Google Distance"); JLabel label1 = new JLabel("参数一"); JLabel label2 = new JLabel("参数二"); JLabel label3 = new JLabel("结果"); //三行一列的网格布局 frame.setLayout(new GridLayout(3, 1)); //第一行流式布局 JPanel panel1 = new JPanel(); panel1.setLayout(new FlowLayout()); panel1.add(label1); JTextField textField1 = new JTextField(20); panel1.add(textField1); //第二行流式布局 JPanel panel2 = new JPanel(); panel2.setLayout(new FlowLayout()); panel2.add(label2); JTextField textField2 = new JTextField(20); panel2.add(textField2); //第三行流式布局 JPanel panel3 = new JPanel(); panel3.setLayout(new FlowLayout()); panel3.add(label3); JTextField textField3 = new JTextField(20); textField3.setEditable(false);//结果框不可更改 panel3.add(textField3); JButton query = new JButton("查询");//查询按钮 //给查询按钮加上事件监听器 query.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; textField3.setText(String.valueOf( NormalizedGoogleDistance.NGD( textField1.getText(),textField2.getText() ))); &#125; &#125;); panel3.add(query); frame.setSize(300, 300); //设置窗口居中 Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize(); frame.setLocation((dimension.width-frame.getWidth())/2, (dimension.height-frame.getHeight())/2); //添加到网格布局中 frame.add(panel1);frame.add(panel2);frame.add(panel3); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); frame.setResizable(false); &#125; public static void main(String[] args) &#123; try &#123; //设置皮肤 UIManager.setLookAndFeel("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel"); NGDUI ui = new NGDUI(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考文献【1】RudiL.Cilibrasi and PaulM.B.Vitanyi. The Google Similarity Distance 【J】IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, VOL.19, NO3, MARCH2007, P370–383【2】张玉芳,艾东梅,黄 涛,熊忠阳.结合编辑距离和Google距离的语义标注方法 【A】计算机应用研究，2010年2月，第二期，第二十七卷【3】匿名. Normalized Google distance，维基百科，https://en.wikipedia.org/wiki/Normalized_Google_distance【4】pinyangtenglong的专栏. 归一化Google距离（Normalized Google Distance），CSDN博客，http://blog.csdn.net/pinyangtenglong/article/details/26963015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式(第二版)]]></title>
      <url>%2F2016%2F12%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E7%89%88%2F</url>
      <content type="text"><![CDATA[之前的例子可能不太恰当，于是我就又想了一个例子。 定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 大体思路 德云社有很多分社，遍布大江南北。人们每每提到德云社，总是对一种剧场的总称。因此德云社是一种接口。它有enter进入方法。 南京德云社是全国的德云社之一，每当有人enter进入就会提示。 售票员Conductor也是德云社一员，他可以是任何德云社的售票员。售票员会提前咨询场馆有多少座位，max由剧场座位数seats决定。超过max人就禁止观众进入。 观众Audience都有名字，可以进入任意的德云社。观众必须经过售票员，售票员是哪个德云社的代理，观众就进入哪一个。 UML类图 实际代码德云社接口1234public interface DeYunShe &#123; void enter(Audience audience); int getSeats();&#125; 南京德云社123456789101112public class NanJingDeYunShe implements DeYunShe &#123; public static final int seats=3; @Override public void enter(Audience audience) &#123; System.out.println(audience.getName()+" entered!"); &#125; @Override public int getSeats() &#123; return seats; &#125;&#125; 售票员1234567891011121314151617181920212223242526public class Conductor implements DeYunShe &#123; private int max=0; private int audiences=0; private DeYunShe dys; public Conductor(DeYunShe dys) &#123; this.dys = dys; &#125; @Override public int getSeats() &#123; max = dys.getSeats(); return 0; &#125; @Override public void enter(Audience audience) &#123; if (audiences&lt;max) &#123; dys.enter(audience); audiences++; &#125;else &#123; System.out.println(audience.getName()+" is not allowed to enter!"); &#125; &#125;&#125; 观众123456789public class Audience &#123; private String name; public Audience(String n) &#123; name = n; &#125; public String getName()&#123; return name; &#125;&#125; 测试123456789public class Test &#123; public static void main(String[] args) &#123; Conductor proxy = new Conductor(new NanJingDeYunShe()); for(int i=1;i&lt;=5;i++)&#123; proxy.enter(new Audience("Audience"+i)); &#125; &#125;&#125; 运行结果 实验请将本例补充完整，并且增加北京德云社，让这个售票员做它的代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[太平歌词白蛇传]]></title>
      <url>%2F2016%2F12%2F04%2F%E5%A4%AA%E5%B9%B3%E6%AD%8C%E8%AF%8D%E7%99%BD%E8%9B%87%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[太平歌词白蛇传唱词个人整理 我认为应该这样停顿，就简单的画了一下 我爱这门艺术，不希望它完了 杭州/美景/盖世无双西湖岸/奇花异草/四（了）季（个）清香春游/苏堤/桃红柳绿那夏赏/荷花/映满了池塘这秋观/明月/如同碧水冬看/瑞雪/铺满了山岗我表的是/峨眉山白蛇下界在这上天/怒恼了张玉皇怒冲冲/差法海/临了凡界在这金山/寺内把这方丈当这一天/许汉文/烧香还愿老法海/拦去路/有语开腔我算定/你的妻/多了年的怪蟒缠绕你/结连理/盗取真阳有许仙/闻此言/魂飞魄散留在了/文殊院/未转钱塘青白蛇/一怒就找到了寺院那手指/山门骂和尚放出来/儿夫还则罢了若不然/青锋剑下秃头命亡众僧人/急忙忙/把这山门关上那抱头/鼠窜/往内藏小青儿/拘来了/这个虾兵蟹将众水族/显神通/水淹佛堂老法海/坐在了莲台/掐诀念咒那水也涨/庙也长/漫不了山墙钱塘县的/众黎民/遭了涂炭数十万/生灵在水内亡半悬空/又来了/天兵天将那金吒木吒哪吒太子/托塔的天王四值/功曹/二十八宿那梅山/六将/灌口的杨二郎李天王/一怒就祭起了宝塔脸森森/要把这白蛇来伤魁星爷/发恻隐/放她逃走只因她/腹内怀有状元郎老法海唤过了许仙/开言道我赐你/佛钵/去把妖降许汉文/接过了佛钵/心肠硬扭回/头来/够奔了钱塘在这一(呀)路上/点点/飘散/桃杏雨潇潇/不断/柳风扬顾不得/连理枝儿/狂风吹散顾不得/比翼鸟儿/棍下伤亡玉碎/珠沉人何在(哎这)镜花/水月两分张穿大街/过小巷/来的多么快启珠帘/走进来这负心郎白娘子/见佛钵/得得得得颤战兢兢/玉体/粉了面的娇惶尊丈夫/高抬手/把奴容让止不住/秋波儿/泪(了)洒胸膛曾记得/游湖借伞百般恩爱曾记得/那红罗帐下/会鸳鸯那五月/初五/端阳日大不该/夫妻对坐饮雄黄三杯酒/下咽喉/醉倒在绡金帐(嘞嘿)现原形/吓得儿夫/命见阎王奴为你/长寿山/盗来了还阳草还与那/守山的神将/是大战了一场多亏了/寿星爷/发了恻隐赠了那/保命丹/我这转回了家乡我进门来呀/用金丹那/撬牙关/把这金丹灌下搭救/儿夫你转还阳我只说/到金山/你是烧香还愿有谁知/飞灾横祸落在身旁到如今你手托佛钵/回家转口口/声声要把妖降看起来/红颜薄命/真命苦空叫我/眼泪流干/寸断了肝肠奴好比/月当空被这乌云遮上奴好比/瓦上霜我是难见日光奴好比/弓断弦我是回天无术奴好比/泥牛入海隐入汪洋我这看起来/人生苦短无药救不由得/两泪流干散落胸膛忙把娇儿怀中抱为娘我/有句话/细听端详再吃口/为娘断肠的乳从今/往后离了亲娘埋怨/休把娘埋怨埋怨/你父丧尽了天良回头来/忙把这青儿叫你与我/扶养这小儿郎忙把娇儿递过去这刷拉拉/佛钵放了豪光白娘子/压在了这雷峰塔终朝每日/受凄凉好可叹/十八年/灾数才满许梦娇/中状元/雷峰塔下见了亲娘我一言/唱不尽这白蛇传/我是愿诸位/合家欢乐是福寿绵长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式]]></title>
      <url>%2F2016%2F11%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义代理模式的定义：Provide a surrogate or placeholder for another object to control access to it(为其他对象提供一种代理以控制对这个对象的访问)。 意义使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 UML 角色及职责 Subject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。 Proxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后工作。 应用场景举例(老司机发车咯)代理模式好有一比。比从何来？好比西门庆找潘金莲，让王婆做代理。(营养跟不上的请自觉下车233)首先，我们先定义这种女人。一种类型嘛，肯定要是接口12345678public interface KindWoman &#123; //这种女人能做什么事情呢？ public void makeEyesWithMan();//抛媚眼 public void happyWithMan();//你懂得 &#125; 之后，我们要有潘金莲 1234567891011121314public class PanJinLian implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("潘金莲和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("潘金莲抛媚眼..."); &#125;&#125; 然后王婆登场 123456789101112131415161718192021222324252627public class WangPo implements KindWoman &#123; private KindWoman kindWoman; public WangPo()&#123; //默认的话是潘金莲的代理 this.kindWoman = new PanJinLian(); &#125; //她可以是KindWoman的任何一个女人的代理，只要你是这一类型 public WangPo(KindWoman kindWoman)&#123; this.kindWoman = kindWoman; &#125; @Override public void happyWithMan() &#123; //自己老了，但可以叫年轻的代替。 this.kindWoman.happyWithMan(); &#125; @Override public void makeEyesWithMan() &#123; //王婆年纪大了，谁看她抛媚眼啊 this.kindWoman.makeEyesWithMan(); &#125;&#125; 女主角都上场了，接下来该男主角西门大官人了 123456789101112131415161718192021/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); &#125;&#125; 之后再来个玉堂春吧233，虽然不是一个时代(详见《三堂会审玉堂春》)。 1234567891011121314public class YuTangChun implements KindWoman&#123; @Override public void happyWithMan() &#123; System.out.println("玉堂春和男人你懂得..."); &#125; @Override public void makeEyesWithMan() &#123; System.out.println("玉堂春抛媚眼..."); &#125;&#125; 这之后，西门庆可以勾搭玉堂春123456789101112131415161718192021222324252627/** *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下， *西门庆看痴迷了，被王婆看到了，就开始撮合两人好事， *王婆作为潘金莲的代理人收了不少好处费 */public class XiMenQing &#123; /** * @param args */ public static void main(String[] args) &#123; WangPo wangPo; //把王婆叫出来 wangPo = new WangPo(); //然后西门庆说，我要和潘金莲你懂得，然后王婆就安排了西门庆丢筷子那出戏： wangPo.makeEyesWithMan(); //看到没有，表面是王婆在做，其实爽的是潘金莲 wangPo.happyWithMan(); //西门庆勾搭玉堂春 YuTangChun yuTangChun = new YuTangChun(); wangPo = new WangPo(yuTangChun); wangPo.makeEyesWithMan(); wangPo.happyWithMan(); &#125;&#125; 故事背后深层含义(车到站了哦)代理模式主要使用了java的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚得很，同样一个接口呗。今天老司机就开到这里吧，红红火火恍恍惚惚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线索二叉树的遍历方法]]></title>
      <url>%2F2016%2F11%2F22%2F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[求各种次序线索树非叶子结点的前驱和后继的方法： 前序线索树非叶子结点p的前驱：p的双亲结点； 前序线索树非叶子结点p的后继：若p有左孩子，则后继为其左孩子，否则后继是其右孩子。 后序线索树非叶子结点p的前驱：若p有右孩子，则后继为其右孩子；否则后继是其左孩子。 后序线索树非叶子结点p的后继：若p为根结点，则其后继为空；若p为其双亲结点的右孩子，或p为左孩子且其双亲结点无右孩子，则p的后继为其双亲结点； 若p为左孩子，且其双亲结点有右孩子，则其后继为双亲结点右子树的第一个结点（最左边结点）。 中序线索树非叶子结点p的前驱：左子树的最后一个结点（最右边的结点）。 中序线索树非叶子结点p的后继：右子树的第一个结点（最左边结点）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Umbrello UML 文档个人翻译]]></title>
      <url>%2F2016%2F11%2F01%2FUmbrello-UML-%E6%96%87%E6%A1%A3%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91%2F</url>
      <content type="text"><![CDATA[只是关于UML基础知识部分的翻译 UML基础关于UML这一章节会给你一个UML基础知识的概览。一定要记住，这不是一个综合的UML教程，而只是一个可以当做UML教程的对UML的简要介绍。统一建模语言(UML)是一个图表语言，或者说是用来指定、可视化和文档化面向对象软件的模型的标记法。UML不是一种开发方法，这也就意味着它不会一五一十地告诉你每一步要做什么和如何设计你的系统，但是它可以帮助你可视化你的设计和与他人沟通。UML为面向对象程序设计而生，对其他编程模式作用有限。UML由许多模板元素组成，这些模板元素代表着软件系统的不同部分。UML的元素被用来创建示意图，这些示意图代表着一个软件系统的一部分或者一个方面。Umbrello支持以下的这些表： 用例图：展示演员（系统的用户）、用例（用户使用系统的情形）以及他们之间的关系。 类图：展示类和他们之间的关系。 顺序图：展示对象以及一系列的对象对其他对象的方法调用。 协作图：展示对象和他们之间的关系，重点强调参与信息传递的对象。 状态图：展示状态、状态变化以及对象或一部分系统中的事件。 活动图：展示活动以及伴随着部分系统的事件而产生的活动改变。 组件图：展示高级编程组件。比如KParts和Java Beans 配置图：展示组件的实例和它们之间的关系。 实体关系图：展示数据、关系以及数据之间的约束。 UML元素用例图用例图描述一组用例以及参与这个过程的演员之间的关系和依赖。 一定要注意，用例图不适合描述设计，也不能描述系统的内部。用例图是为简化与未来的系统用户、顾客的交流而生的，对决定系统的需求有很大帮助。用例图可以说明系统是做什么的，但是不会也不能确定如何去做。 用例用例站在演员的角度描述一组系统中的产生确定结果的活动。用例是系统中成员和系统自身的特殊互动的描述。它们代表系统的外部接口，并且指定系统要做什么。 使用用例的时候，一定要注意以下几点： 每一个用例至少和一位演员关联 每一个用例都有一个发起人 每一个用例都会产生相关结果 用例之间也可以有联系，其中有三种联系最为典型： &lt;&lt;include&gt;&gt;指一个用例发生在另一个用例之中 &lt;&lt;extends&gt;&gt;指在某些情况或者某些点（扩展点），一个用例被另一个扩展 Generalization指一个用例继承一个“高级”用例的特性，可以像类继承一样覆盖或者添加特性 演员演员是系统之外的实体，他们以参与用例的方式与系统交互。他们可以是人、其他电脑系统或者外部事件。 演员不代表实体人或者系统，而是角色。也就是说一个人在做不同操作时可以是不同的演员。 用例描述用例描述是用例的文本描述，通常以连接用例的笔记或文档的形式，解释发生在用例中的过程或活动。 类图类图展示组成系统的不同类以及它们之间关联的方式。类图是静态图表，因为虽然它展示了类之间的关系，但是没有展示它们之间的调用方法。 类一个类定义了一组对象的属性和方法。所有这个类的对象共享同样的行为，具有同种属性（各有各的值）。类和类型不一样，类型意思更广泛。 在UML中，矩形代表类，分为三个部分，分别写有类名、属性（成员变量）、操作（函数、方法）。 属性在UML中，属性最少要展示它们的名字，也可以展示它们的类型、初值等其他属性。属性也可以展示它们的可见度： +代表公有属性（public） #代表保护属性（protected） -代表私有属性（private） 操作操作（方法）也是最少要展示它们的名字，还可以展示它们的参数列表和返回值。像属性一样，操作也可以展示他们的可见度： +代表公有操作（public） #代表保护操作（protected） -代表私有操作（private） 模板类里面可以有模板，它是一个未指定的类或类型。模板在类初始化的时候特化（比如一个对象生成时）。模板存在于现代C++以及Java1.5以后的版本（称为泛型） 类之间的联系类之间可以有多种联系： 泛化继承是面向对象编程的基本概念。子类可以获得父类的所有属性和操作，也可以覆盖或修改其中的一部分，还可以添加自己的属性和操作。 在UML中，两个类之间的泛化联系分层展示了基类和派生类之间的继承关系。在UML中，泛化由连接两个类的直线和指向基类的箭头表示。 关联关联是类之间的一种关系，给出一般语义和结构用来说明对象之间的多种”联系”方式。 关联是对象之间的交流机制，它描述了不同类之间的关系（实体对象之间的联系称为object connection，也叫链接（link））。 关联可以在特化联系的目的中起作用，可以是单向的也可以是双向的(indicates if the two objects participating in the relationship can send messages to the other, of if only one of them knows about the other)。 关联的两端各有一个数值，它们规定了关联一端的一个对象能和另一端的多少对象联系。 在UML中，关联被表示成连接具有关联关系的两个类的直线，它也可以展示参与者的角色以及数量。数量被表示成非负数的一个范围[min..max]，如果max一端是*，则代表无穷。 聚合聚合是两个不等权参与类之间的特殊联系。两个参与类之间构成”整体-部分”关系。聚合关系描述”整体类”是如何由”部分类”构成的。对于聚合关系来说，”整体类”数量永远只能为1。 在UML中，聚合由”整体类”一侧有空心菱形的直线来表示。 组合组合是一种非常强的聚合。组合中的”部分类”只能依存于”整体类”而存在。整体消亡则部分消亡。比如书和书中的章节。 在UML中，组合由”整体类”一侧有实心菱形的直线来表示。 其他类图组件类图中除了类还有其他的组件。 接口借口是抽象的类，不能直接产生实例。它们可以包含操作，但是不能包含属性。类可以继承与实现接口，之后产生实例。 数据类型数据类型是编程语言内置的基元，比如整形数和布尔型数。它们不能与类关联，但是类可以与它们关联。 枚举枚举是值的简单列表，比如一周七天。枚举的选项称为枚举常量。像数据类型一样，它们不能与类关联，但是类可以与它们关联。 包包代表编程语言中的命名空间。在图表中它们被用来表示系统的一部分。它可以包含多个甚至上百个类。 顺序图顺序图展示了指定时间界限内多个对象之间的信息交换。对象是类的实例。顺序图特别强调了对象发送信息的顺序和时间。 在顺序图中，垂直的虚线代表对象，并且对象的名字写在最上端。时间轴也是垂直的，越向下时间越晚。因此信息在对象间以带有操作和参数的箭头的形式传递。 消息可以是同步的，那种普通的信息调用，这时控制权被传递给被调用的对象直到方法结束。也可以是异步的，控制权一直在主调对象。同步消息在被调对象那里有一个垂直的方框，用来展示程序控制流。 协作图协作图展示参与特定事件的对象之间的互动。协作图展示的信息或多或少的与顺序图有相似之处，但是顺序图更加侧重于强调互动何时发生，而协作图突出对象之间的关系和拓扑结构。 在协作图当中，对象之间的信息传递用箭头表示，展现了信息的名称、参数以及信息的顺序。协作图非常适合展示一个特定的程序流或者情形，而且它还是最好的说明或解释程序逻辑的一个过程的图表之一。 状态机图状态图展示一个对象生命周期中的不同状态以及使对象改变状态的刺激(stimuli)。 状态机图将对象看作状态机(state machines)或者有限的自动化，它可以处于有限多个状态中的一个状态，并且可以因为有限多种状态之中的一种而改变它的状态。比如说一个网络服务器类型的对象在它的生命周期中可以有以下状态： 就绪 监听 运行 停止 可以让它改变状态的事件有： 对象被创建 对象收到监听信息 有客户端通过网络请求连接 有客户端终止请求 请求被执行并且结束 对象收到停止信息 …… 状态状态是状态机图的砖瓦。一个状态确定的属于一个类，它代表了一个类的属性的值的集合。一个UML状态描述了一个特定的类的一个对象的内部状态。 要注意，不是每一个对象属性的变化都应该用状态表示，只有明显影响对象的工作状态的变化才用状态表示。 有两种状态是特殊的：开始和结束。之所以说它们特殊，是因为没有任何事件可以让对象返回初始状态或离开结束状态。 活动图活动图描述系统中活动的顺序,是一种只含有活动或者大部分是活动，特殊类型的状态机图。 活动图比较类似于程序流图，不同在于所有的活动都清楚地与对象连接。 活动图永远和类、操作或用例相关联。 活动图支持顺序和并行的活动。 活动一个活动是一个流程中的一步。一个活动是系统的一个状态，它带有内部的活动以及至少一个的外部转换(outgoing transition)。如果存在不同的情况，活动也可以有多个外部转换。 活动也可以有层次结构。活动需要体现子图的向内向外转换。（an Activity can be composed of several ‘detail’ Activities, in which case the incoming and outgoing transitions should match the incoming and outgoing transitions of the detail diagram.）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(3) chgrp]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-3-chgrp%2F</url>
      <content type="text"><![CDATA[Linux chgrp命令Linux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...] 参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 实例实例1：改变文件的群组属性：chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log [root@localhost test]# chgrp -v bin log2012.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 说明： 将log2012.log文件由root群组改为bin群组 实例2：根据指定文件改变文件的群组属性chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root root 61 11-13 06:03 log2013.log [root@localhost test]# chgrp --reference=log2012.log log2013.log [root@localhost test]# ll ---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log -rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log 说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(2) chattr]]></title>
      <url>%2F2016%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4-2-chattr%2F</url>
      <content type="text"><![CDATA[Linux命令(2) chattrLinux chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途。即append,设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件，只有root才能设定这个属性。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 语法chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...] 参数 -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 实例用chattr命令防止系统中某个关键文件被修改：chattr +i /etc/resolv.conflsattr /etc/resolv.conf会显示如下属性----i-------- /etc/resolv.conf 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：chattr +a /var/log/messages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令(1) cat]]></title>
      <url>%2F2016%2F10%2F28%2FLinux%E5%91%BD%E4%BB%A4-1-cat%2F</url>
      <content type="text"><![CDATA[Linux命令(1) catcat命令用于把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案) 使用权限所有用户 语法格式cat [-AbeEnstTuv] [--help] [--version] fileName 参数说明 -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 实例说明把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -n textfile1 &gt; textfile2 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。cat -b textfile1 textfile2 &gt;&gt; textfile3 清空/etc/test.txt档案内容cat /dev/null &gt; /etc/test.txt cat 也可以用来制作镜像文件。例如要制作软碟的像文件，将软碟放好后输入cat /dev/fd0 &gt; OUTFILE 相反的，如果想把 image file 写到软碟，请输入cat IMG_FILE &gt; /dev/fd0 备注 OUTFILE 指输出的镜像文件名。 IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用在制作开机磁片。]]></content>
    </entry>

    
  
  
</search>
